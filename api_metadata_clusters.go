/*
XMS API

XMS is the controller of distributed storage system

API version: XSCALEROS_6.4.000.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MetadataClustersAPIService MetadataClustersAPI service
type MetadataClustersAPIService service

type ApiAddMetadataServicesToClusterRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
	body *MetadataClusterAddServicesReq
}

// metadata services
func (r ApiAddMetadataServicesToClusterRequest) Body(body MetadataClusterAddServicesReq) ApiAddMetadataServicesToClusterRequest {
	r.body = &body
	return r
}

func (r ApiAddMetadataServicesToClusterRequest) Execute() (*MetadataClusterResp, *http.Response, error) {
	return r.ApiService.AddMetadataServicesToClusterExecute(r)
}

/*
AddMetadataServicesToCluster Method for AddMetadataServicesToCluster

Add metadata services to cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiAddMetadataServicesToClusterRequest
*/
func (a *MetadataClustersAPIService) AddMetadataServicesToCluster(ctx context.Context, metadataClusterId int64) ApiAddMetadataServicesToClusterRequest {
	return ApiAddMetadataServicesToClusterRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterResp
func (a *MetadataClustersAPIService) AddMetadataServicesToClusterExecute(r ApiAddMetadataServicesToClusterRequest) (*MetadataClusterResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.AddMetadataServicesToCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}:add-metadata-services"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMetadataClusterRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	body *MetadataClusterCreateReq
	clusterId *string
}

// metadata cluster info
func (r ApiCreateMetadataClusterRequest) Body(body MetadataClusterCreateReq) ApiCreateMetadataClusterRequest {
	r.body = &body
	return r
}

// cluster id
func (r ApiCreateMetadataClusterRequest) ClusterId(clusterId string) ApiCreateMetadataClusterRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiCreateMetadataClusterRequest) Execute() (*MetadataClusterResp, *http.Response, error) {
	return r.ApiService.CreateMetadataClusterExecute(r)
}

/*
CreateMetadataCluster Method for CreateMetadataCluster

Create metadata cluster on specific disk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMetadataClusterRequest
*/
func (a *MetadataClustersAPIService) CreateMetadataCluster(ctx context.Context) ApiCreateMetadataClusterRequest {
	return ApiCreateMetadataClusterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MetadataClusterResp
func (a *MetadataClustersAPIService) CreateMetadataClusterExecute(r ApiCreateMetadataClusterRequest) (*MetadataClusterResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.CreateMetadataCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMetadataClusterRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
}

func (r ApiDeleteMetadataClusterRequest) Execute() (*MetadataClusterResp, *http.Response, error) {
	return r.ApiService.DeleteMetadataClusterExecute(r)
}

/*
DeleteMetadataCluster Method for DeleteMetadataCluster

delete a metadata cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiDeleteMetadataClusterRequest
*/
func (a *MetadataClustersAPIService) DeleteMetadataCluster(ctx context.Context, metadataClusterId int64) ApiDeleteMetadataClusterRequest {
	return ApiDeleteMetadataClusterRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterResp
func (a *MetadataClustersAPIService) DeleteMetadataClusterExecute(r ApiDeleteMetadataClusterRequest) (*MetadataClusterResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.DeleteMetadataCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetadataClusterRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
}

func (r ApiGetMetadataClusterRequest) Execute() (*MetadataClusterResp, *http.Response, error) {
	return r.ApiService.GetMetadataClusterExecute(r)
}

/*
GetMetadataCluster Method for GetMetadataCluster

get a metadata cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiGetMetadataClusterRequest
*/
func (a *MetadataClustersAPIService) GetMetadataCluster(ctx context.Context, metadataClusterId int64) ApiGetMetadataClusterRequest {
	return ApiGetMetadataClusterRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterResp
func (a *MetadataClustersAPIService) GetMetadataClusterExecute(r ApiGetMetadataClusterRequest) (*MetadataClusterResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.GetMetadataCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetadataClusterPredictionsRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
}

func (r ApiGetMetadataClusterPredictionsRequest) Execute() (*MetadataClusterPredictionsResp, *http.Response, error) {
	return r.ApiService.GetMetadataClusterPredictionsExecute(r)
}

/*
GetMetadataClusterPredictions Method for GetMetadataClusterPredictions

get a metadata cluster's prediction

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiGetMetadataClusterPredictionsRequest
*/
func (a *MetadataClustersAPIService) GetMetadataClusterPredictions(ctx context.Context, metadataClusterId int64) ApiGetMetadataClusterPredictionsRequest {
	return ApiGetMetadataClusterPredictionsRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterPredictionsResp
func (a *MetadataClustersAPIService) GetMetadataClusterPredictionsExecute(r ApiGetMetadataClusterPredictionsRequest) (*MetadataClusterPredictionsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterPredictionsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.GetMetadataClusterPredictions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}/predictions"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMetadataClusterSamplesRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
	durationBegin *string
	durationEnd *string
	period *string
}

// duration begin timestamp
func (r ApiGetMetadataClusterSamplesRequest) DurationBegin(durationBegin string) ApiGetMetadataClusterSamplesRequest {
	r.durationBegin = &durationBegin
	return r
}

// duration end timestamp
func (r ApiGetMetadataClusterSamplesRequest) DurationEnd(durationEnd string) ApiGetMetadataClusterSamplesRequest {
	r.durationEnd = &durationEnd
	return r
}

// samples period
func (r ApiGetMetadataClusterSamplesRequest) Period(period string) ApiGetMetadataClusterSamplesRequest {
	r.period = &period
	return r
}

func (r ApiGetMetadataClusterSamplesRequest) Execute() (*MetadataClusterSamplesResp, *http.Response, error) {
	return r.ApiService.GetMetadataClusterSamplesExecute(r)
}

/*
GetMetadataClusterSamples Method for GetMetadataClusterSamples

get samples of a metadata cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiGetMetadataClusterSamplesRequest
*/
func (a *MetadataClustersAPIService) GetMetadataClusterSamples(ctx context.Context, metadataClusterId int64) ApiGetMetadataClusterSamplesRequest {
	return ApiGetMetadataClusterSamplesRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterSamplesResp
func (a *MetadataClustersAPIService) GetMetadataClusterSamplesExecute(r ApiGetMetadataClusterSamplesRequest) (*MetadataClusterSamplesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterSamplesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.GetMetadataClusterSamples")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}/samples"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.durationBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_begin", r.durationBegin, "form", "")
	}
	if r.durationEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_end", r.durationEnd, "form", "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMetadataClustersRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	limit *int64
	offset *int64
	clusterId *string
	hostId *int64
	metadataClusterId *int64
	q *string
	sort *string
}

// paging param
func (r ApiListMetadataClustersRequest) Limit(limit int64) ApiListMetadataClustersRequest {
	r.limit = &limit
	return r
}

// paging param
func (r ApiListMetadataClustersRequest) Offset(offset int64) ApiListMetadataClustersRequest {
	r.offset = &offset
	return r
}

// cluster id
func (r ApiListMetadataClustersRequest) ClusterId(clusterId string) ApiListMetadataClustersRequest {
	r.clusterId = &clusterId
	return r
}

// host id
func (r ApiListMetadataClustersRequest) HostId(hostId int64) ApiListMetadataClustersRequest {
	r.hostId = &hostId
	return r
}

// metadata cluster id
func (r ApiListMetadataClustersRequest) MetadataClusterId(metadataClusterId int64) ApiListMetadataClustersRequest {
	r.metadataClusterId = &metadataClusterId
	return r
}

// query param of search
func (r ApiListMetadataClustersRequest) Q(q string) ApiListMetadataClustersRequest {
	r.q = &q
	return r
}

// sort param of search
func (r ApiListMetadataClustersRequest) Sort(sort string) ApiListMetadataClustersRequest {
	r.sort = &sort
	return r
}

func (r ApiListMetadataClustersRequest) Execute() (*MetadataClustersResp, *http.Response, error) {
	return r.ApiService.ListMetadataClustersExecute(r)
}

/*
ListMetadataClusters Method for ListMetadataClusters

List all metadata clusters in the cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListMetadataClustersRequest
*/
func (a *MetadataClustersAPIService) ListMetadataClusters(ctx context.Context) ApiListMetadataClustersRequest {
	return ApiListMetadataClustersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MetadataClustersResp
func (a *MetadataClustersAPIService) ListMetadataClustersExecute(r ApiListMetadataClustersRequest) (*MetadataClustersResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClustersResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.ListMetadataClusters")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	if r.hostId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host_id", r.hostId, "form", "")
	}
	if r.metadataClusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metadata_cluster_id", r.metadataClusterId, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveMetadataServicesFromClusterRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
	body *MetadataClusterRemoveServicesReq
}

// metadata services
func (r ApiRemoveMetadataServicesFromClusterRequest) Body(body MetadataClusterRemoveServicesReq) ApiRemoveMetadataServicesFromClusterRequest {
	r.body = &body
	return r
}

func (r ApiRemoveMetadataServicesFromClusterRequest) Execute() (*MetadataClusterResp, *http.Response, error) {
	return r.ApiService.RemoveMetadataServicesFromClusterExecute(r)
}

/*
RemoveMetadataServicesFromCluster Method for RemoveMetadataServicesFromCluster

Remove metadata services from cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiRemoveMetadataServicesFromClusterRequest
*/
func (a *MetadataClustersAPIService) RemoveMetadataServicesFromCluster(ctx context.Context, metadataClusterId int64) ApiRemoveMetadataServicesFromClusterRequest {
	return ApiRemoveMetadataServicesFromClusterRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterResp
func (a *MetadataClustersAPIService) RemoveMetadataServicesFromClusterExecute(r ApiRemoveMetadataServicesFromClusterRequest) (*MetadataClusterResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.RemoveMetadataServicesFromCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}:remove-metadata-services"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMetadataClusterToStretchedRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
	body *MetadataClusterSetStretchedReq
}

// cluster stretched info
func (r ApiSetMetadataClusterToStretchedRequest) Body(body MetadataClusterSetStretchedReq) ApiSetMetadataClusterToStretchedRequest {
	r.body = &body
	return r
}

func (r ApiSetMetadataClusterToStretchedRequest) Execute() (*MetadataClusterResp, *http.Response, error) {
	return r.ApiService.SetMetadataClusterToStretchedExecute(r)
}

/*
SetMetadataClusterToStretched Method for SetMetadataClusterToStretched

set metadata cluster to stretched

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiSetMetadataClusterToStretchedRequest
*/
func (a *MetadataClustersAPIService) SetMetadataClusterToStretched(ctx context.Context, metadataClusterId int64) ApiSetMetadataClusterToStretchedRequest {
	return ApiSetMetadataClusterToStretchedRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterResp
func (a *MetadataClustersAPIService) SetMetadataClusterToStretchedExecute(r ApiSetMetadataClusterToStretchedRequest) (*MetadataClusterResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.SetMetadataClusterToStretched")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}:set-stretched"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMetadataClusterTransLocatorRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
	body *MetadataClusterSetTransLocaterReq
}

// transfer locator
func (r ApiSetMetadataClusterTransLocatorRequest) Body(body MetadataClusterSetTransLocaterReq) ApiSetMetadataClusterTransLocatorRequest {
	r.body = &body
	return r
}

func (r ApiSetMetadataClusterTransLocatorRequest) Execute() (*MetadataClusterResp, *http.Response, error) {
	return r.ApiService.SetMetadataClusterTransLocatorExecute(r)
}

/*
SetMetadataClusterTransLocator Method for SetMetadataClusterTransLocator

set transfer locator of metadata cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiSetMetadataClusterTransLocatorRequest
*/
func (a *MetadataClustersAPIService) SetMetadataClusterTransLocator(ctx context.Context, metadataClusterId int64) ApiSetMetadataClusterTransLocatorRequest {
	return ApiSetMetadataClusterTransLocatorRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterResp
func (a *MetadataClustersAPIService) SetMetadataClusterTransLocatorExecute(r ApiSetMetadataClusterTransLocatorRequest) (*MetadataClusterResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.SetMetadataClusterTransLocator")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}:set-trans-locator"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMetadataClusterRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
	body *MetadataClusterUpdateReq
}

// metadata cluster info
func (r ApiUpdateMetadataClusterRequest) Body(body MetadataClusterUpdateReq) ApiUpdateMetadataClusterRequest {
	r.body = &body
	return r
}

func (r ApiUpdateMetadataClusterRequest) Execute() (*MetadataClusterResp, *http.Response, error) {
	return r.ApiService.UpdateMetadataClusterExecute(r)
}

/*
UpdateMetadataCluster Method for UpdateMetadataCluster

update metadata cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiUpdateMetadataClusterRequest
*/
func (a *MetadataClustersAPIService) UpdateMetadataCluster(ctx context.Context, metadataClusterId int64) ApiUpdateMetadataClusterRequest {
	return ApiUpdateMetadataClusterRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterResp
func (a *MetadataClustersAPIService) UpdateMetadataClusterExecute(r ApiUpdateMetadataClusterRequest) (*MetadataClusterResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.UpdateMetadataCluster")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdatePrimaryDcRequest struct {
	ctx context.Context
	ApiService *MetadataClustersAPIService
	metadataClusterId int64
	body *MetadataClusterUpdatePrimaryDcReq
}

// metadata cluster info
func (r ApiUpdatePrimaryDcRequest) Body(body MetadataClusterUpdatePrimaryDcReq) ApiUpdatePrimaryDcRequest {
	r.body = &body
	return r
}

func (r ApiUpdatePrimaryDcRequest) Execute() (*MetadataClusterResp, *http.Response, error) {
	return r.ApiService.UpdatePrimaryDcExecute(r)
}

/*
UpdatePrimaryDc Method for UpdatePrimaryDc

update primary datacenter of metadata cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param metadataClusterId metadata cluster id
 @return ApiUpdatePrimaryDcRequest
*/
func (a *MetadataClustersAPIService) UpdatePrimaryDc(ctx context.Context, metadataClusterId int64) ApiUpdatePrimaryDcRequest {
	return ApiUpdatePrimaryDcRequest{
		ApiService: a,
		ctx: ctx,
		metadataClusterId: metadataClusterId,
	}
}

// Execute executes the request
//  @return MetadataClusterResp
func (a *MetadataClustersAPIService) UpdatePrimaryDcExecute(r ApiUpdatePrimaryDcRequest) (*MetadataClusterResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetadataClusterResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MetadataClustersAPIService.UpdatePrimaryDc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/metadata-clusters/{metadata_cluster_id}:update-primary-dc"
	localVarPath = strings.Replace(localVarPath, "{"+"metadata_cluster_id"+"}", url.PathEscape(parameterValueToString(r.metadataClusterId, "metadataClusterId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
