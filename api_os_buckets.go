/*
XMS API

XMS is the controller of distributed storage system

API version: XSCALEROS_6.4.000.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// OsBucketsAPIService OsBucketsAPI service
type OsBucketsAPIService service

type ApiAddCustomLabelsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketCustomLabelsAddReq
}

// bucket custom labels info
func (r ApiAddCustomLabelsRequest) Body(body OSBucketCustomLabelsAddReq) ApiAddCustomLabelsRequest {
	r.body = &body
	return r
}

func (r ApiAddCustomLabelsRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.AddCustomLabelsExecute(r)
}

/*
AddCustomLabels Method for AddCustomLabels

add object storage bucket custom labels

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiAddCustomLabelsRequest
*/
func (a *OsBucketsAPIService) AddCustomLabels(ctx context.Context, bucketId int64) ApiAddCustomLabelsRequest {
	return ApiAddCustomLabelsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) AddCustomLabelsExecute(r ApiAddCustomLabelsRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.AddCustomLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:add-custom-labels"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddOSReplicationPathsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketAddReplicationPathsReq
}

// replication paths info
func (r ApiAddOSReplicationPathsRequest) Body(body OSBucketAddReplicationPathsReq) ApiAddOSReplicationPathsRequest {
	r.body = &body
	return r
}

func (r ApiAddOSReplicationPathsRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.AddOSReplicationPathsExecute(r)
}

/*
AddOSReplicationPaths Method for AddOSReplicationPaths

add os replication paths for os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiAddOSReplicationPathsRequest
*/
func (a *OsBucketsAPIService) AddOSReplicationPaths(ctx context.Context, bucketId int64) ApiAddOSReplicationPathsRequest {
	return ApiAddOSReplicationPathsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) AddOSReplicationPathsExecute(r ApiAddOSReplicationPathsRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.AddOSReplicationPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:add-os-replication-paths"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddOSReplicationZonesRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketAddReplicationZonesReq
}

// replication zones info
func (r ApiAddOSReplicationZonesRequest) Body(body OSBucketAddReplicationZonesReq) ApiAddOSReplicationZonesRequest {
	r.body = &body
	return r
}

func (r ApiAddOSReplicationZonesRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.AddOSReplicationZonesExecute(r)
}

/*
AddOSReplicationZones Method for AddOSReplicationZones

add os replication zones for os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiAddOSReplicationZonesRequest
*/
func (a *OsBucketsAPIService) AddOSReplicationZones(ctx context.Context, bucketId int64) ApiAddOSReplicationZonesRequest {
	return ApiAddOSReplicationZonesRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) AddOSReplicationZonesExecute(r ApiAddOSReplicationZonesRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.AddOSReplicationZones")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:add-os-replication-zones"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchGetObjectStorageSamplesRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	ids *string
}

// bucket ids
func (r ApiBatchGetObjectStorageSamplesRequest) Ids(ids string) ApiBatchGetObjectStorageSamplesRequest {
	r.ids = &ids
	return r
}

func (r ApiBatchGetObjectStorageSamplesRequest) Execute() (*MultiObjectStorageBucketsSamplesResp, *http.Response, error) {
	return r.ApiService.BatchGetObjectStorageSamplesExecute(r)
}

/*
BatchGetObjectStorageSamples Method for BatchGetObjectStorageSamples

Get samples of multiple object storage buckets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchGetObjectStorageSamplesRequest
*/
func (a *OsBucketsAPIService) BatchGetObjectStorageSamples(ctx context.Context) ApiBatchGetObjectStorageSamplesRequest {
	return ApiBatchGetObjectStorageSamplesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiObjectStorageBucketsSamplesResp
func (a *OsBucketsAPIService) BatchGetObjectStorageSamplesExecute(r ApiBatchGetObjectStorageSamplesRequest) (*MultiObjectStorageBucketsSamplesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiObjectStorageBucketsSamplesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.BatchGetObjectStorageSamples")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/samples"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelDeleteBucketRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
}

func (r ApiCancelDeleteBucketRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.CancelDeleteBucketExecute(r)
}

/*
CancelDeleteBucket Method for CancelDeleteBucket

cancel delete bucket task

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiCancelDeleteBucketRequest
*/
func (a *OsBucketsAPIService) CancelDeleteBucket(ctx context.Context, bucketId int64) ApiCancelDeleteBucketRequest {
	return ApiCancelDeleteBucketRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) CancelDeleteBucketExecute(r ApiCancelDeleteBucketRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.CancelDeleteBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBucketRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	body *ObjectStorageBucketCreateReq
	clusterId *string
}

// bucket info
func (r ApiCreateBucketRequest) Body(body ObjectStorageBucketCreateReq) ApiCreateBucketRequest {
	r.body = &body
	return r
}

// cluster id
func (r ApiCreateBucketRequest) ClusterId(clusterId string) ApiCreateBucketRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiCreateBucketRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.CreateBucketExecute(r)
}

/*
CreateBucket Method for CreateBucket

Create os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBucketRequest
*/
func (a *OsBucketsAPIService) CreateBucket(ctx context.Context) ApiCreateBucketRequest {
	return ApiCreateBucketRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) CreateBucketExecute(r ApiCreateBucketRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.CreateBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateObjectStorageBucketNFSClientsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *ObjectStorageBucketNFSClientsCreateReq
}

// nfs client info
func (r ApiCreateObjectStorageBucketNFSClientsRequest) Body(body ObjectStorageBucketNFSClientsCreateReq) ApiCreateObjectStorageBucketNFSClientsRequest {
	r.body = &body
	return r
}

func (r ApiCreateObjectStorageBucketNFSClientsRequest) Execute() (*RawObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.CreateObjectStorageBucketNFSClientsExecute(r)
}

/*
CreateObjectStorageBucketNFSClients Method for CreateObjectStorageBucketNFSClients

create nfs client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiCreateObjectStorageBucketNFSClientsRequest
*/
func (a *OsBucketsAPIService) CreateObjectStorageBucketNFSClients(ctx context.Context, bucketId int64) ApiCreateObjectStorageBucketNFSClientsRequest {
	return ApiCreateObjectStorageBucketNFSClientsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return RawObjectStorageBucketResp
func (a *OsBucketsAPIService) CreateObjectStorageBucketNFSClientsExecute(r ApiCreateObjectStorageBucketNFSClientsRequest) (*RawObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RawObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.CreateObjectStorageBucketNFSClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}/nfs-clients"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBucketRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	force *bool
}

// force delete or not
func (r ApiDeleteBucketRequest) Force(force bool) ApiDeleteBucketRequest {
	r.force = &force
	return r
}

func (r ApiDeleteBucketRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.DeleteBucketExecute(r)
}

/*
DeleteBucket Method for DeleteBucket

delete object storage bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiDeleteBucketRequest
*/
func (a *OsBucketsAPIService) DeleteBucket(ctx context.Context, bucketId int64) ApiDeleteBucketRequest {
	return ApiDeleteBucketRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) DeleteBucketExecute(r ApiDeleteBucketRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.DeleteBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteObjectStorageBucketNFSClientsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *ObjectStorageBucketNFSClientsDeleteReq
}

// nfs client info
func (r ApiDeleteObjectStorageBucketNFSClientsRequest) Body(body ObjectStorageBucketNFSClientsDeleteReq) ApiDeleteObjectStorageBucketNFSClientsRequest {
	r.body = &body
	return r
}

func (r ApiDeleteObjectStorageBucketNFSClientsRequest) Execute() (*RawObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.DeleteObjectStorageBucketNFSClientsExecute(r)
}

/*
DeleteObjectStorageBucketNFSClients Method for DeleteObjectStorageBucketNFSClients

delete nfs clients

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiDeleteObjectStorageBucketNFSClientsRequest
*/
func (a *OsBucketsAPIService) DeleteObjectStorageBucketNFSClients(ctx context.Context, bucketId int64) ApiDeleteObjectStorageBucketNFSClientsRequest {
	return ApiDeleteObjectStorageBucketNFSClientsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return RawObjectStorageBucketResp
func (a *OsBucketsAPIService) DeleteObjectStorageBucketNFSClientsExecute(r ApiDeleteObjectStorageBucketNFSClientsRequest) (*RawObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RawObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.DeleteObjectStorageBucketNFSClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}/nfs-clients"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteObjectStorageLifecycleRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
}

func (r ApiDeleteObjectStorageLifecycleRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.DeleteObjectStorageLifecycleExecute(r)
}

/*
DeleteObjectStorageLifecycle Method for DeleteObjectStorageLifecycle

delete object storage lifecycle

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiDeleteObjectStorageLifecycleRequest
*/
func (a *OsBucketsAPIService) DeleteObjectStorageLifecycle(ctx context.Context, bucketId int64) ApiDeleteObjectStorageLifecycleRequest {
	return ApiDeleteObjectStorageLifecycleRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) DeleteObjectStorageLifecycleExecute(r ApiDeleteObjectStorageLifecycleRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.DeleteObjectStorageLifecycle")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}/lifecycle"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBucketRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
}

func (r ApiGetBucketRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.GetBucketExecute(r)
}

/*
GetBucket Method for GetBucket

Get object storage bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiGetBucketRequest
*/
func (a *OsBucketsAPIService) GetBucket(ctx context.Context, bucketId int64) ApiGetBucketRequest {
	return ApiGetBucketRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) GetBucketExecute(r ApiGetBucketRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.GetBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOSBucketOriginPullSamplesRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	originMode *string
	durationBegin *string
	durationEnd *string
	period *string
}

// origin mode
func (r ApiGetOSBucketOriginPullSamplesRequest) OriginMode(originMode string) ApiGetOSBucketOriginPullSamplesRequest {
	r.originMode = &originMode
	return r
}

// duration begin timestamp
func (r ApiGetOSBucketOriginPullSamplesRequest) DurationBegin(durationBegin string) ApiGetOSBucketOriginPullSamplesRequest {
	r.durationBegin = &durationBegin
	return r
}

// duration end timestamp
func (r ApiGetOSBucketOriginPullSamplesRequest) DurationEnd(durationEnd string) ApiGetOSBucketOriginPullSamplesRequest {
	r.durationEnd = &durationEnd
	return r
}

// samples period
func (r ApiGetOSBucketOriginPullSamplesRequest) Period(period string) ApiGetOSBucketOriginPullSamplesRequest {
	r.period = &period
	return r
}

func (r ApiGetOSBucketOriginPullSamplesRequest) Execute() (*OSBucketOriginPullSamplesResp, *http.Response, error) {
	return r.ApiService.GetOSBucketOriginPullSamplesExecute(r)
}

/*
GetOSBucketOriginPullSamples Method for GetOSBucketOriginPullSamples

get an os bucket's origin pull Samples

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiGetOSBucketOriginPullSamplesRequest
*/
func (a *OsBucketsAPIService) GetOSBucketOriginPullSamples(ctx context.Context, bucketId int64) ApiGetOSBucketOriginPullSamplesRequest {
	return ApiGetOSBucketOriginPullSamplesRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return OSBucketOriginPullSamplesResp
func (a *OsBucketsAPIService) GetOSBucketOriginPullSamplesExecute(r ApiGetOSBucketOriginPullSamplesRequest) (*OSBucketOriginPullSamplesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OSBucketOriginPullSamplesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.GetOSBucketOriginPullSamples")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}/origin_pull_samples"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.originMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "origin_mode", r.originMode, "form", "")
	}
	if r.durationBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_begin", r.durationBegin, "form", "")
	}
	if r.durationEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_end", r.durationEnd, "form", "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectStorageBucketNFSClientRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	clientId int64
}

func (r ApiGetObjectStorageBucketNFSClientRequest) Execute() (*ObjectStorageBucketNFSClientResp, *http.Response, error) {
	return r.ApiService.GetObjectStorageBucketNFSClientExecute(r)
}

/*
GetObjectStorageBucketNFSClient Method for GetObjectStorageBucketNFSClient

show nfs client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @param clientId nfs client id
 @return ApiGetObjectStorageBucketNFSClientRequest
*/
func (a *OsBucketsAPIService) GetObjectStorageBucketNFSClient(ctx context.Context, bucketId int64, clientId int64) ApiGetObjectStorageBucketNFSClientRequest {
	return ApiGetObjectStorageBucketNFSClientRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
		clientId: clientId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketNFSClientResp
func (a *OsBucketsAPIService) GetObjectStorageBucketNFSClientExecute(r ApiGetObjectStorageBucketNFSClientRequest) (*ObjectStorageBucketNFSClientResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketNFSClientResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.GetObjectStorageBucketNFSClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}/nfs-clients/{client_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client_id"+"}", url.PathEscape(parameterValueToString(r.clientId, "clientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetObjectStorageBucketSamplesRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	durationBegin *string
	durationEnd *string
	period *string
}

// duration begin timestamp
func (r ApiGetObjectStorageBucketSamplesRequest) DurationBegin(durationBegin string) ApiGetObjectStorageBucketSamplesRequest {
	r.durationBegin = &durationBegin
	return r
}

// duration end timestamp
func (r ApiGetObjectStorageBucketSamplesRequest) DurationEnd(durationEnd string) ApiGetObjectStorageBucketSamplesRequest {
	r.durationEnd = &durationEnd
	return r
}

// samples period
func (r ApiGetObjectStorageBucketSamplesRequest) Period(period string) ApiGetObjectStorageBucketSamplesRequest {
	r.period = &period
	return r
}

func (r ApiGetObjectStorageBucketSamplesRequest) Execute() (*ObjectStorageBucketSamplesResp, *http.Response, error) {
	return r.ApiService.GetObjectStorageBucketSamplesExecute(r)
}

/*
GetObjectStorageBucketSamples Method for GetObjectStorageBucketSamples

get an object storage bucket's Samples

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiGetObjectStorageBucketSamplesRequest
*/
func (a *OsBucketsAPIService) GetObjectStorageBucketSamples(ctx context.Context, bucketId int64) ApiGetObjectStorageBucketSamplesRequest {
	return ApiGetObjectStorageBucketSamplesRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketSamplesResp
func (a *OsBucketsAPIService) GetObjectStorageBucketSamplesExecute(r ApiGetObjectStorageBucketSamplesRequest) (*ObjectStorageBucketSamplesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketSamplesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.GetObjectStorageBucketSamples")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}/samples"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.durationBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_begin", r.durationBegin, "form", "")
	}
	if r.durationEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_end", r.durationEnd, "form", "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBucketsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	clusterId *string
	limit *int64
	offset *int64
	name *string
	osPolicyId *int64
	osUserId *int64
	replicationUuid *string
	virtual *bool
	q *string
	sort *string
}

// cluster id
func (r ApiListBucketsRequest) ClusterId(clusterId string) ApiListBucketsRequest {
	r.clusterId = &clusterId
	return r
}

// paging param
func (r ApiListBucketsRequest) Limit(limit int64) ApiListBucketsRequest {
	r.limit = &limit
	return r
}

// paging param
func (r ApiListBucketsRequest) Offset(offset int64) ApiListBucketsRequest {
	r.offset = &offset
	return r
}

// name of object storage buckets
func (r ApiListBucketsRequest) Name(name string) ApiListBucketsRequest {
	r.name = &name
	return r
}

// The id of policy object storage buckets belong to
func (r ApiListBucketsRequest) OsPolicyId(osPolicyId int64) ApiListBucketsRequest {
	r.osPolicyId = &osPolicyId
	return r
}

// The id of user object storage buckets belong to
func (r ApiListBucketsRequest) OsUserId(osUserId int64) ApiListBucketsRequest {
	r.osUserId = &osUserId
	return r
}

// The uuid of replication os buckets belong to
func (r ApiListBucketsRequest) ReplicationUuid(replicationUuid string) ApiListBucketsRequest {
	r.replicationUuid = &replicationUuid
	return r
}

// Virtual bucket or not
func (r ApiListBucketsRequest) Virtual(virtual bool) ApiListBucketsRequest {
	r.virtual = &virtual
	return r
}

// query param of search
func (r ApiListBucketsRequest) Q(q string) ApiListBucketsRequest {
	r.q = &q
	return r
}

// sort param of search
func (r ApiListBucketsRequest) Sort(sort string) ApiListBucketsRequest {
	r.sort = &sort
	return r
}

func (r ApiListBucketsRequest) Execute() (*ObjectStorageBucketsResp, *http.Response, error) {
	return r.ApiService.ListBucketsExecute(r)
}

/*
ListBuckets Method for ListBuckets

List object storage buckets

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBucketsRequest
*/
func (a *OsBucketsAPIService) ListBuckets(ctx context.Context) ApiListBucketsRequest {
	return ApiListBucketsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketsResp
func (a *OsBucketsAPIService) ListBucketsExecute(r ApiListBucketsRequest) (*ObjectStorageBucketsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.ListBuckets")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.osPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "os_policy_id", r.osPolicyId, "form", "")
	}
	if r.osUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "os_user_id", r.osUserId, "form", "")
	}
	if r.replicationUuid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replication_uuid", r.replicationUuid, "form", "")
	}
	if r.virtual != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "virtual", r.virtual, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListObjectStorageBucketNFSClientsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	limit *int64
	offset *int64
	clusterId *string
}

// paging param
func (r ApiListObjectStorageBucketNFSClientsRequest) Limit(limit int64) ApiListObjectStorageBucketNFSClientsRequest {
	r.limit = &limit
	return r
}

// paging param
func (r ApiListObjectStorageBucketNFSClientsRequest) Offset(offset int64) ApiListObjectStorageBucketNFSClientsRequest {
	r.offset = &offset
	return r
}

// cluster id
func (r ApiListObjectStorageBucketNFSClientsRequest) ClusterId(clusterId string) ApiListObjectStorageBucketNFSClientsRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiListObjectStorageBucketNFSClientsRequest) Execute() (*ObjectStorageBucketNFSClientsResp, *http.Response, error) {
	return r.ApiService.ListObjectStorageBucketNFSClientsExecute(r)
}

/*
ListObjectStorageBucketNFSClients Method for ListObjectStorageBucketNFSClients

List nfs clients

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiListObjectStorageBucketNFSClientsRequest
*/
func (a *OsBucketsAPIService) ListObjectStorageBucketNFSClients(ctx context.Context, bucketId int64) ApiListObjectStorageBucketNFSClientsRequest {
	return ApiListObjectStorageBucketNFSClientsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketNFSClientsResp
func (a *OsBucketsAPIService) ListObjectStorageBucketNFSClientsExecute(r ApiListObjectStorageBucketNFSClientsRequest) (*ObjectStorageBucketNFSClientsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketNFSClientsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.ListObjectStorageBucketNFSClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}/nfs-clients"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveCustomLabelsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketCustomLabelsRemoveReq
}

// custom labels info
func (r ApiRemoveCustomLabelsRequest) Body(body OSBucketCustomLabelsRemoveReq) ApiRemoveCustomLabelsRequest {
	r.body = &body
	return r
}

func (r ApiRemoveCustomLabelsRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.RemoveCustomLabelsExecute(r)
}

/*
RemoveCustomLabels Method for RemoveCustomLabels

remove object storage bucket custom labels

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId object storage bucket id
 @return ApiRemoveCustomLabelsRequest
*/
func (a *OsBucketsAPIService) RemoveCustomLabels(ctx context.Context, bucketId int64) ApiRemoveCustomLabelsRequest {
	return ApiRemoveCustomLabelsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) RemoveCustomLabelsExecute(r ApiRemoveCustomLabelsRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.RemoveCustomLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:remove-custom-labels"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveOSBucketLoggingsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketRemoveLoggingsReq
}

// os bucket loggings info
func (r ApiRemoveOSBucketLoggingsRequest) Body(body OSBucketRemoveLoggingsReq) ApiRemoveOSBucketLoggingsRequest {
	r.body = &body
	return r
}

func (r ApiRemoveOSBucketLoggingsRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.RemoveOSBucketLoggingsExecute(r)
}

/*
RemoveOSBucketLoggings Method for RemoveOSBucketLoggings

Remove os bucket loggings of os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiRemoveOSBucketLoggingsRequest
*/
func (a *OsBucketsAPIService) RemoveOSBucketLoggings(ctx context.Context, bucketId int64) ApiRemoveOSBucketLoggingsRequest {
	return ApiRemoveOSBucketLoggingsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) RemoveOSBucketLoggingsExecute(r ApiRemoveOSBucketLoggingsRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.RemoveOSBucketLoggings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:remove-os-bucket-loggings"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveOSReplicationPathsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketRemoveReplicationPathsReq
}

// replication paths info
func (r ApiRemoveOSReplicationPathsRequest) Body(body OSBucketRemoveReplicationPathsReq) ApiRemoveOSReplicationPathsRequest {
	r.body = &body
	return r
}

func (r ApiRemoveOSReplicationPathsRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.RemoveOSReplicationPathsExecute(r)
}

/*
RemoveOSReplicationPaths Method for RemoveOSReplicationPaths

remove os replication paths for os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiRemoveOSReplicationPathsRequest
*/
func (a *OsBucketsAPIService) RemoveOSReplicationPaths(ctx context.Context, bucketId int64) ApiRemoveOSReplicationPathsRequest {
	return ApiRemoveOSReplicationPathsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) RemoveOSReplicationPathsExecute(r ApiRemoveOSReplicationPathsRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.RemoveOSReplicationPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:remove-os-replication-paths"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveOSReplicationZonesRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketRemoveReplicationZonesReq
	force *bool
}

// replication zones info
func (r ApiRemoveOSReplicationZonesRequest) Body(body OSBucketRemoveReplicationZonesReq) ApiRemoveOSReplicationZonesRequest {
	r.body = &body
	return r
}

// force delete os replication zone even if target zone is dead
func (r ApiRemoveOSReplicationZonesRequest) Force(force bool) ApiRemoveOSReplicationZonesRequest {
	r.force = &force
	return r
}

func (r ApiRemoveOSReplicationZonesRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.RemoveOSReplicationZonesExecute(r)
}

/*
RemoveOSReplicationZones Method for RemoveOSReplicationZones

remove os replication zones for os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiRemoveOSReplicationZonesRequest
*/
func (a *OsBucketsAPIService) RemoveOSReplicationZones(ctx context.Context, bucketId int64) ApiRemoveOSReplicationZonesRequest {
	return ApiRemoveOSReplicationZonesRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) RemoveOSReplicationZonesExecute(r ApiRemoveOSReplicationZonesRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.RemoveOSReplicationZones")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:remove-os-replication-zones"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetAccessLoggingRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketSetAccessLoggingReq
}

// access logging info
func (r ApiSetAccessLoggingRequest) Body(body OSBucketSetAccessLoggingReq) ApiSetAccessLoggingRequest {
	r.body = &body
	return r
}

func (r ApiSetAccessLoggingRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.SetAccessLoggingExecute(r)
}

/*
SetAccessLogging Method for SetAccessLogging

Set access logging of os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiSetAccessLoggingRequest
*/
func (a *OsBucketsAPIService) SetAccessLogging(ctx context.Context, bucketId int64) ApiSetAccessLoggingRequest {
	return ApiSetAccessLoggingRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) SetAccessLoggingExecute(r ApiSetAccessLoggingRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.SetAccessLogging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:set-access-logging"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetMetadataSearchRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketMetadataSearchSetReq
}

// bucket metadata search info
func (r ApiSetMetadataSearchRequest) Body(body OSBucketMetadataSearchSetReq) ApiSetMetadataSearchRequest {
	r.body = &body
	return r
}

func (r ApiSetMetadataSearchRequest) Execute() (*ObjectStorageBucketsResp, *http.Response, error) {
	return r.ApiService.SetMetadataSearchExecute(r)
}

/*
SetMetadataSearch Method for SetMetadataSearch

set object storage bucket metadata search

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId object storage bucket id
 @return ApiSetMetadataSearchRequest
*/
func (a *OsBucketsAPIService) SetMetadataSearch(ctx context.Context, bucketId int64) ApiSetMetadataSearchRequest {
	return ApiSetMetadataSearchRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketsResp
func (a *OsBucketsAPIService) SetMetadataSearchExecute(r ApiSetMetadataSearchRequest) (*ObjectStorageBucketsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.SetMetadataSearch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:set-metadata-search"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetOSBucketPolicyRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketPolicySetReq
}

// bucket policy info
func (r ApiSetOSBucketPolicyRequest) Body(body OSBucketPolicySetReq) ApiSetOSBucketPolicyRequest {
	r.body = &body
	return r
}

func (r ApiSetOSBucketPolicyRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.SetOSBucketPolicyExecute(r)
}

/*
SetOSBucketPolicy Method for SetOSBucketPolicy

set object storage bucket policy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiSetOSBucketPolicyRequest
*/
func (a *OsBucketsAPIService) SetOSBucketPolicy(ctx context.Context, bucketId int64) ApiSetOSBucketPolicyRequest {
	return ApiSetOSBucketPolicyRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) SetOSBucketPolicyExecute(r ApiSetOSBucketPolicyRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.SetOSBucketPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:set-bucket-policy"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetObjectStorageClassRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketSetObjectStorageClassReq
}

// object storage class info
func (r ApiSetObjectStorageClassRequest) Body(body OSBucketSetObjectStorageClassReq) ApiSetObjectStorageClassRequest {
	r.body = &body
	return r
}

func (r ApiSetObjectStorageClassRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.SetObjectStorageClassExecute(r)
}

/*
SetObjectStorageClass Method for SetObjectStorageClass

Set bucket object match storage class

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiSetObjectStorageClassRequest
*/
func (a *OsBucketsAPIService) SetObjectStorageClass(ctx context.Context, bucketId int64) ApiSetObjectStorageClassRequest {
	return ApiSetObjectStorageClassRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) SetObjectStorageClassExecute(r ApiSetObjectStorageClassRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.SetObjectStorageClass")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:set-object-storage-class"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetObjectStorageLifecycleRulesRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *ObjectStorageLifecycleSetReq
}

// lifecyce rules info
func (r ApiSetObjectStorageLifecycleRulesRequest) Body(body ObjectStorageLifecycleSetReq) ApiSetObjectStorageLifecycleRulesRequest {
	r.body = &body
	return r
}

func (r ApiSetObjectStorageLifecycleRulesRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.SetObjectStorageLifecycleRulesExecute(r)
}

/*
SetObjectStorageLifecycleRules Method for SetObjectStorageLifecycleRules

Set object storage lifecycle rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiSetObjectStorageLifecycleRulesRequest
*/
func (a *OsBucketsAPIService) SetObjectStorageLifecycleRules(ctx context.Context, bucketId int64) ApiSetObjectStorageLifecycleRulesRequest {
	return ApiSetObjectStorageLifecycleRulesRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) SetObjectStorageLifecycleRulesExecute(r ApiSetObjectStorageLifecycleRulesRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.SetObjectStorageLifecycleRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}/lifecycle"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuspendAccessLoggingsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
}

func (r ApiSuspendAccessLoggingsRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.SuspendAccessLoggingsExecute(r)
}

/*
SuspendAccessLoggings Method for SuspendAccessLoggings

suspend access logging for os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiSuspendAccessLoggingsRequest
*/
func (a *OsBucketsAPIService) SuspendAccessLoggings(ctx context.Context, bucketId int64) ApiSuspendAccessLoggingsRequest {
	return ApiSuspendAccessLoggingsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) SuspendAccessLoggingsExecute(r ApiSuspendAccessLoggingsRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.SuspendAccessLoggings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:suspend-access-logging"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuspendOSReplicationPathsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketUpdateReplicationPathsReq
}

// replication paths info
func (r ApiSuspendOSReplicationPathsRequest) Body(body OSBucketUpdateReplicationPathsReq) ApiSuspendOSReplicationPathsRequest {
	r.body = &body
	return r
}

func (r ApiSuspendOSReplicationPathsRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.SuspendOSReplicationPathsExecute(r)
}

/*
SuspendOSReplicationPaths Method for SuspendOSReplicationPaths

suspend os replication paths for os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiSuspendOSReplicationPathsRequest
*/
func (a *OsBucketsAPIService) SuspendOSReplicationPaths(ctx context.Context, bucketId int64) ApiSuspendOSReplicationPathsRequest {
	return ApiSuspendOSReplicationPathsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) SuspendOSReplicationPathsExecute(r ApiSuspendOSReplicationPathsRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.SuspendOSReplicationPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:suspend-os-replication-paths"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSwitchOwnerOSZoneRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketSwitchOwnerOSZoneReq
	force *bool
}

// new owner os zone info
func (r ApiSwitchOwnerOSZoneRequest) Body(body OSBucketSwitchOwnerOSZoneReq) ApiSwitchOwnerOSZoneRequest {
	r.body = &body
	return r
}

// force to switch even if old owner zone is dead
func (r ApiSwitchOwnerOSZoneRequest) Force(force bool) ApiSwitchOwnerOSZoneRequest {
	r.force = &force
	return r
}

func (r ApiSwitchOwnerOSZoneRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.SwitchOwnerOSZoneExecute(r)
}

/*
SwitchOwnerOSZone Method for SwitchOwnerOSZone

Switch owner zone of os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiSwitchOwnerOSZoneRequest
*/
func (a *OsBucketsAPIService) SwitchOwnerOSZone(ctx context.Context, bucketId int64) ApiSwitchOwnerOSZoneRequest {
	return ApiSwitchOwnerOSZoneRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) SwitchOwnerOSZoneExecute(r ApiSwitchOwnerOSZoneRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.SwitchOwnerOSZone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:switch-owner-os-zone"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsetAccessLoggingRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
}

func (r ApiUnsetAccessLoggingRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.UnsetAccessLoggingExecute(r)
}

/*
UnsetAccessLogging Method for UnsetAccessLogging

Unset access logging of os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiUnsetAccessLoggingRequest
*/
func (a *OsBucketsAPIService) UnsetAccessLogging(ctx context.Context, bucketId int64) ApiUnsetAccessLoggingRequest {
	return ApiUnsetAccessLoggingRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) UnsetAccessLoggingExecute(r ApiUnsetAccessLoggingRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.UnsetAccessLogging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:unset-access-logging"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsetOSBucketPolicyRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
}

func (r ApiUnsetOSBucketPolicyRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.UnsetOSBucketPolicyExecute(r)
}

/*
UnsetOSBucketPolicy Method for UnsetOSBucketPolicy

unset object storage bucket policy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiUnsetOSBucketPolicyRequest
*/
func (a *OsBucketsAPIService) UnsetOSBucketPolicy(ctx context.Context, bucketId int64) ApiUnsetOSBucketPolicyRequest {
	return ApiUnsetOSBucketPolicyRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) UnsetOSBucketPolicyExecute(r ApiUnsetOSBucketPolicyRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.UnsetOSBucketPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:unset-bucket-policy"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsuspendAccessLoggingRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
}

func (r ApiUnsuspendAccessLoggingRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.UnsuspendAccessLoggingExecute(r)
}

/*
UnsuspendAccessLogging Method for UnsuspendAccessLogging

unsuspend access logging for os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiUnsuspendAccessLoggingRequest
*/
func (a *OsBucketsAPIService) UnsuspendAccessLogging(ctx context.Context, bucketId int64) ApiUnsuspendAccessLoggingRequest {
	return ApiUnsuspendAccessLoggingRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) UnsuspendAccessLoggingExecute(r ApiUnsuspendAccessLoggingRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.UnsuspendAccessLogging")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:unsuspend-access-logging"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsuspendOSReplicationPathsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketUpdateReplicationPathsReq
}

// replication paths info
func (r ApiUnsuspendOSReplicationPathsRequest) Body(body OSBucketUpdateReplicationPathsReq) ApiUnsuspendOSReplicationPathsRequest {
	r.body = &body
	return r
}

func (r ApiUnsuspendOSReplicationPathsRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.UnsuspendOSReplicationPathsExecute(r)
}

/*
UnsuspendOSReplicationPaths Method for UnsuspendOSReplicationPaths

unsuspend os replication paths for os bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiUnsuspendOSReplicationPathsRequest
*/
func (a *OsBucketsAPIService) UnsuspendOSReplicationPaths(ctx context.Context, bucketId int64) ApiUnsuspendOSReplicationPathsRequest {
	return ApiUnsuspendOSReplicationPathsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) UnsuspendOSReplicationPathsExecute(r ApiUnsuspendOSReplicationPathsRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.UnsuspendOSReplicationPaths")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:unsuspend-os-replication-paths"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBucketRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *ObjectStorageBucketUpdateReq
}

// bucket info
func (r ApiUpdateBucketRequest) Body(body ObjectStorageBucketUpdateReq) ApiUpdateBucketRequest {
	r.body = &body
	return r
}

func (r ApiUpdateBucketRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.UpdateBucketExecute(r)
}

/*
UpdateBucket Method for UpdateBucket

Update object storage bucket

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @return ApiUpdateBucketRequest
*/
func (a *OsBucketsAPIService) UpdateBucket(ctx context.Context, bucketId int64) ApiUpdateBucketRequest {
	return ApiUpdateBucketRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) UpdateBucketExecute(r ApiUpdateBucketRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.UpdateBucket")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCustomLabelsRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	body *OSBucketCustomLabelsUpdateReq
}

// custom labels info
func (r ApiUpdateCustomLabelsRequest) Body(body OSBucketCustomLabelsUpdateReq) ApiUpdateCustomLabelsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateCustomLabelsRequest) Execute() (*ObjectStorageBucketResp, *http.Response, error) {
	return r.ApiService.UpdateCustomLabelsExecute(r)
}

/*
UpdateCustomLabels Method for UpdateCustomLabels

update object storage bucket custom labels

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId object storage bucket id
 @return ApiUpdateCustomLabelsRequest
*/
func (a *OsBucketsAPIService) UpdateCustomLabels(ctx context.Context, bucketId int64) ApiUpdateCustomLabelsRequest {
	return ApiUpdateCustomLabelsRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketResp
func (a *OsBucketsAPIService) UpdateCustomLabelsExecute(r ApiUpdateCustomLabelsRequest) (*ObjectStorageBucketResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.UpdateCustomLabels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}:update-custom-labels"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateObjectStorageBucketNFSClientRequest struct {
	ctx context.Context
	ApiService *OsBucketsAPIService
	bucketId int64
	clientId int64
	body *ObjectStorageBucketNFSClientUpdateReq
}

// nfs client info
func (r ApiUpdateObjectStorageBucketNFSClientRequest) Body(body ObjectStorageBucketNFSClientUpdateReq) ApiUpdateObjectStorageBucketNFSClientRequest {
	r.body = &body
	return r
}

func (r ApiUpdateObjectStorageBucketNFSClientRequest) Execute() (*ObjectStorageBucketNFSClientResp, *http.Response, error) {
	return r.ApiService.UpdateObjectStorageBucketNFSClientExecute(r)
}

/*
UpdateObjectStorageBucketNFSClient Method for UpdateObjectStorageBucketNFSClient

update nfs client

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bucketId bucket id
 @param clientId nfs client id
 @return ApiUpdateObjectStorageBucketNFSClientRequest
*/
func (a *OsBucketsAPIService) UpdateObjectStorageBucketNFSClient(ctx context.Context, bucketId int64, clientId int64) ApiUpdateObjectStorageBucketNFSClientRequest {
	return ApiUpdateObjectStorageBucketNFSClientRequest{
		ApiService: a,
		ctx: ctx,
		bucketId: bucketId,
		clientId: clientId,
	}
}

// Execute executes the request
//  @return ObjectStorageBucketNFSClientResp
func (a *OsBucketsAPIService) UpdateObjectStorageBucketNFSClientExecute(r ApiUpdateObjectStorageBucketNFSClientRequest) (*ObjectStorageBucketNFSClientResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectStorageBucketNFSClientResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OsBucketsAPIService.UpdateObjectStorageBucketNFSClient")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/os-buckets/{bucket_id}/nfs-clients/{client_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"bucket_id"+"}", url.PathEscape(parameterValueToString(r.bucketId, "bucketId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"client_id"+"}", url.PathEscape(parameterValueToString(r.clientId, "clientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
