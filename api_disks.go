/*
XMS API

XMS is the controller of distributed storage system

API version: XSCALEROS_6.4.000.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DisksAPIService DisksAPI service
type DisksAPIService service

type ApiCreatePartitionsRequest struct {
	ctx context.Context
	ApiService *DisksAPIService
	diskId int64
	body *PartitionsCreateReq
	num *int64
}

// partitions info
func (r ApiCreatePartitionsRequest) Body(body PartitionsCreateReq) ApiCreatePartitionsRequest {
	r.body = &body
	return r
}

// num of cache partitions to create
func (r ApiCreatePartitionsRequest) Num(num int64) ApiCreatePartitionsRequest {
	r.num = &num
	return r
}

func (r ApiCreatePartitionsRequest) Execute() (*DiskResp, *http.Response, error) {
	return r.ApiService.CreatePartitionsExecute(r)
}

/*
CreatePartitions Method for CreatePartitions

create cache partitions for disk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param diskId disk id
 @return ApiCreatePartitionsRequest
*/
func (a *DisksAPIService) CreatePartitions(ctx context.Context, diskId int64) ApiCreatePartitionsRequest {
	return ApiCreatePartitionsRequest{
		ApiService: a,
		ctx: ctx,
		diskId: diskId,
	}
}

// Execute executes the request
//  @return DiskResp
func (a *DisksAPIService) CreatePartitionsExecute(r ApiCreatePartitionsRequest) (*DiskResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiskResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisksAPIService.CreatePartitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disks/{disk_id}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"disk_id"+"}", url.PathEscape(parameterValueToString(r.diskId, "diskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.num != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "num", r.num, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePartitionsRequest struct {
	ctx context.Context
	ApiService *DisksAPIService
	diskId int64
}

func (r ApiDeletePartitionsRequest) Execute() (*DiskResp, *http.Response, error) {
	return r.ApiService.DeletePartitionsExecute(r)
}

/*
DeletePartitions Method for DeletePartitions

delete cache partitions of disk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param diskId disk id
 @return ApiDeletePartitionsRequest
*/
func (a *DisksAPIService) DeletePartitions(ctx context.Context, diskId int64) ApiDeletePartitionsRequest {
	return ApiDeletePartitionsRequest{
		ApiService: a,
		ctx: ctx,
		diskId: diskId,
	}
}

// Execute executes the request
//  @return DiskResp
func (a *DisksAPIService) DeletePartitionsExecute(r ApiDeletePartitionsRequest) (*DiskResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiskResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisksAPIService.DeletePartitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disks/{disk_id}/partitions"
	localVarPath = strings.Replace(localVarPath, "{"+"disk_id"+"}", url.PathEscape(parameterValueToString(r.diskId, "diskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDiskRequest struct {
	ctx context.Context
	ApiService *DisksAPIService
	diskId int64
}

func (r ApiGetDiskRequest) Execute() (*DiskResp, *http.Response, error) {
	return r.ApiService.GetDiskExecute(r)
}

/*
GetDisk Method for GetDisk

Get a disk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param diskId disk id
 @return ApiGetDiskRequest
*/
func (a *DisksAPIService) GetDisk(ctx context.Context, diskId int64) ApiGetDiskRequest {
	return ApiGetDiskRequest{
		ApiService: a,
		ctx: ctx,
		diskId: diskId,
	}
}

// Execute executes the request
//  @return DiskResp
func (a *DisksAPIService) GetDiskExecute(r ApiGetDiskRequest) (*DiskResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiskResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisksAPIService.GetDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disks/{disk_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"disk_id"+"}", url.PathEscape(parameterValueToString(r.diskId, "diskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDiskSamplesRequest struct {
	ctx context.Context
	ApiService *DisksAPIService
	diskId int64
	durationBegin *string
	durationEnd *string
	period *string
}

// duration begin timestamp
func (r ApiGetDiskSamplesRequest) DurationBegin(durationBegin string) ApiGetDiskSamplesRequest {
	r.durationBegin = &durationBegin
	return r
}

// duration end timestamp
func (r ApiGetDiskSamplesRequest) DurationEnd(durationEnd string) ApiGetDiskSamplesRequest {
	r.durationEnd = &durationEnd
	return r
}

// samples period
func (r ApiGetDiskSamplesRequest) Period(period string) ApiGetDiskSamplesRequest {
	r.period = &period
	return r
}

func (r ApiGetDiskSamplesRequest) Execute() (*DiskSamplesResp, *http.Response, error) {
	return r.ApiService.GetDiskSamplesExecute(r)
}

/*
GetDiskSamples Method for GetDiskSamples

get a disk's samples

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param diskId disk id
 @return ApiGetDiskSamplesRequest
*/
func (a *DisksAPIService) GetDiskSamples(ctx context.Context, diskId int64) ApiGetDiskSamplesRequest {
	return ApiGetDiskSamplesRequest{
		ApiService: a,
		ctx: ctx,
		diskId: diskId,
	}
}

// Execute executes the request
//  @return DiskSamplesResp
func (a *DisksAPIService) GetDiskSamplesExecute(r ApiGetDiskSamplesRequest) (*DiskSamplesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiskSamplesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisksAPIService.GetDiskSamples")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disks/{disk_id}/samples"
	localVarPath = strings.Replace(localVarPath, "{"+"disk_id"+"}", url.PathEscape(parameterValueToString(r.diskId, "diskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.durationBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_begin", r.durationBegin, "form", "")
	}
	if r.durationEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_end", r.durationEnd, "form", "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDisksRequest struct {
	ctx context.Context
	ApiService *DisksAPIService
	limit *int64
	offset *int64
	hostId *int64
	clusterId *string
	rebuildDiskId *int64
	isCache *bool
	diskType *string
	usage *string
	used *bool
	q *string
	sort *string
	device *string
	status *string
	ids *string
	hostIds *string
	orderBy *string
}

// paging param
func (r ApiListDisksRequest) Limit(limit int64) ApiListDisksRequest {
	r.limit = &limit
	return r
}

// paging param
func (r ApiListDisksRequest) Offset(offset int64) ApiListDisksRequest {
	r.offset = &offset
	return r
}

// host id
func (r ApiListDisksRequest) HostId(hostId int64) ApiListDisksRequest {
	r.hostId = &hostId
	return r
}

// cluster id
func (r ApiListDisksRequest) ClusterId(clusterId string) ApiListDisksRequest {
	r.clusterId = &clusterId
	return r
}

// disk id to order disk by size and type for rebuilding disk
func (r ApiListDisksRequest) RebuildDiskId(rebuildDiskId int64) ApiListDisksRequest {
	r.rebuildDiskId = &rebuildDiskId
	return r
}

// filter cache disk, deprecated, use &#x60;usage&#x3D;partition&#x60; instead
func (r ApiListDisksRequest) IsCache(isCache bool) ApiListDisksRequest {
	r.isCache = &isCache
	return r
}

// filter disk type
func (r ApiListDisksRequest) DiskType(diskType string) ApiListDisksRequest {
	r.diskType = &diskType
	return r
}

// filter disk usage
func (r ApiListDisksRequest) Usage(usage string) ApiListDisksRequest {
	r.usage = &usage
	return r
}

// filter used
func (r ApiListDisksRequest) Used(used bool) ApiListDisksRequest {
	r.used = &used
	return r
}

// query param of search
func (r ApiListDisksRequest) Q(q string) ApiListDisksRequest {
	r.q = &q
	return r
}

// sort param of search
func (r ApiListDisksRequest) Sort(sort string) ApiListDisksRequest {
	r.sort = &sort
	return r
}

// device name of disk
func (r ApiListDisksRequest) Device(device string) ApiListDisksRequest {
	r.device = &device
	return r
}

// disk status
func (r ApiListDisksRequest) Status(status string) ApiListDisksRequest {
	r.status = &status
	return r
}

// disk comma separate ids
func (r ApiListDisksRequest) Ids(ids string) ApiListDisksRequest {
	r.ids = &ids
	return r
}

// disk.host comma separate ids
func (r ApiListDisksRequest) HostIds(hostIds string) ApiListDisksRequest {
	r.hostIds = &hostIds
	return r
}

// sort param without search, split with comma, e.g. -host.name
func (r ApiListDisksRequest) OrderBy(orderBy string) ApiListDisksRequest {
	r.orderBy = &orderBy
	return r
}

func (r ApiListDisksRequest) Execute() (*DisksResp, *http.Response, error) {
	return r.ApiService.ListDisksExecute(r)
}

/*
ListDisks Method for ListDisks

List all pyhsical disks in the system

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDisksRequest
*/
func (a *DisksAPIService) ListDisks(ctx context.Context) ApiListDisksRequest {
	return ApiListDisksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DisksResp
func (a *DisksAPIService) ListDisksExecute(r ApiListDisksRequest) (*DisksResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DisksResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisksAPIService.ListDisks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disks/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.hostId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host_id", r.hostId, "form", "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	if r.rebuildDiskId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rebuild_disk_id", r.rebuildDiskId, "form", "")
	}
	if r.isCache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_cache", r.isCache, "form", "")
	}
	if r.diskType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "disk_type", r.diskType, "form", "")
	}
	if r.usage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "usage", r.usage, "form", "")
	}
	if r.used != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "used", r.used, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.device != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device", r.device, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	if r.hostIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host_ids", r.hostIds, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRebuildDiskRequest struct {
	ctx context.Context
	ApiService *DisksAPIService
	diskId int64
	body *DiskRebuildReq
}

// new disk info
func (r ApiRebuildDiskRequest) Body(body DiskRebuildReq) ApiRebuildDiskRequest {
	r.body = &body
	return r
}

func (r ApiRebuildDiskRequest) Execute() (*DiskResp, *http.Response, error) {
	return r.ApiService.RebuildDiskExecute(r)
}

/*
RebuildDisk Method for RebuildDisk

rebuild disk with a new disk

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param diskId disk id
 @return ApiRebuildDiskRequest
*/
func (a *DisksAPIService) RebuildDisk(ctx context.Context, diskId int64) ApiRebuildDiskRequest {
	return ApiRebuildDiskRequest{
		ApiService: a,
		ctx: ctx,
		diskId: diskId,
	}
}

// Execute executes the request
//  @return DiskResp
func (a *DisksAPIService) RebuildDiskExecute(r ApiRebuildDiskRequest) (*DiskResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiskResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisksAPIService.RebuildDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disks/{disk_id}:rebuild"
	localVarPath = strings.Replace(localVarPath, "{"+"disk_id"+"}", url.PathEscape(parameterValueToString(r.diskId, "diskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDiskRequest struct {
	ctx context.Context
	ApiService *DisksAPIService
	diskId int64
	disk *DiskUpdateReq
}

// disk info
func (r ApiUpdateDiskRequest) Disk(disk DiskUpdateReq) ApiUpdateDiskRequest {
	r.disk = &disk
	return r
}

func (r ApiUpdateDiskRequest) Execute() (*DiskResp, *http.Response, error) {
	return r.ApiService.UpdateDiskExecute(r)
}

/*
UpdateDisk Method for UpdateDisk

update disk info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param diskId disk id
 @return ApiUpdateDiskRequest
*/
func (a *DisksAPIService) UpdateDisk(ctx context.Context, diskId int64) ApiUpdateDiskRequest {
	return ApiUpdateDiskRequest{
		ApiService: a,
		ctx: ctx,
		diskId: diskId,
	}
}

// Execute executes the request
//  @return DiskResp
func (a *DisksAPIService) UpdateDiskExecute(r ApiUpdateDiskRequest) (*DiskResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DiskResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DisksAPIService.UpdateDisk")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/disks/{disk_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"disk_id"+"}", url.PathEscape(parameterValueToString(r.diskId, "diskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.disk == nil {
		return localVarReturnValue, nil, reportError("disk is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.disk
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
