/*
XMS API

XMS is the controller of distributed storage system

API version: XSCALEROS_6.4.000.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DpBlockAsyncReplicationPairsAPIService DpBlockAsyncReplicationPairsAPI service
type DpBlockAsyncReplicationPairsAPIService service

type ApiAsyncFailoverDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
}

func (r ApiAsyncFailoverDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.AsyncFailoverDpBlockAsyncReplicationPairExecute(r)
}

/*
AsyncFailoverDpBlockAsyncReplicationPair Method for AsyncFailoverDpBlockAsyncReplicationPair

switch the roles of the pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiAsyncFailoverDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) AsyncFailoverDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiAsyncFailoverDpBlockAsyncReplicationPairRequest {
	return ApiAsyncFailoverDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) AsyncFailoverDpBlockAsyncReplicationPairExecute(r ApiAsyncFailoverDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.AsyncFailoverDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}:async-failover"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	body *DpBlockAsyncReplicationPairCreateReq
}

// pair info
func (r ApiCreateDpBlockAsyncReplicationPairRequest) Body(body DpBlockAsyncReplicationPairCreateReq) ApiCreateDpBlockAsyncReplicationPairRequest {
	r.body = &body
	return r
}

func (r ApiCreateDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.CreateDpBlockAsyncReplicationPairExecute(r)
}

/*
CreateDpBlockAsyncReplicationPair Method for CreateDpBlockAsyncReplicationPair

Create dp block async replication pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) CreateDpBlockAsyncReplicationPair(ctx context.Context) ApiCreateDpBlockAsyncReplicationPairRequest {
	return ApiCreateDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) CreateDpBlockAsyncReplicationPairExecute(r ApiCreateDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.CreateDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
	reserveVolume *bool
}

// reserve replicated volume or not
func (r ApiDeleteDpBlockAsyncReplicationPairRequest) ReserveVolume(reserveVolume bool) ApiDeleteDpBlockAsyncReplicationPairRequest {
	r.reserveVolume = &reserveVolume
	return r
}

func (r ApiDeleteDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.DeleteDpBlockAsyncReplicationPairExecute(r)
}

/*
DeleteDpBlockAsyncReplicationPair Method for DeleteDpBlockAsyncReplicationPair

Delete dp block async replication pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiDeleteDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) DeleteDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiDeleteDpBlockAsyncReplicationPairRequest {
	return ApiDeleteDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) DeleteDpBlockAsyncReplicationPairExecute(r ApiDeleteDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.DeleteDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.reserveVolume != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reserve_volume", r.reserveVolume, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFailbackDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
}

func (r ApiFailbackDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.FailbackDpBlockAsyncReplicationPairExecute(r)
}

/*
FailbackDpBlockAsyncReplicationPair Method for FailbackDpBlockAsyncReplicationPair

switch the roles of the pair to synced

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiFailbackDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) FailbackDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiFailbackDpBlockAsyncReplicationPairRequest {
	return ApiFailbackDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) FailbackDpBlockAsyncReplicationPairExecute(r ApiFailbackDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.FailbackDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}:failback"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
}

func (r ApiGetDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.GetDpBlockAsyncReplicationPairExecute(r)
}

/*
GetDpBlockAsyncReplicationPair Method for GetDpBlockAsyncReplicationPair

Get dp block async replication pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiGetDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) GetDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiGetDpBlockAsyncReplicationPairRequest {
	return ApiGetDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) GetDpBlockAsyncReplicationPairExecute(r ApiGetDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.GetDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	blockVolumeId *int64
	dpBlockAsyncReplicationPolicyId *int64
}

// show volume snapshot replication pairs of specific block volume
func (r ApiListDpBlockAsyncReplicationPairRequest) BlockVolumeId(blockVolumeId int64) ApiListDpBlockAsyncReplicationPairRequest {
	r.blockVolumeId = &blockVolumeId
	return r
}

// show volume snapshot replication pairs of specific block async replication policy
func (r ApiListDpBlockAsyncReplicationPairRequest) DpBlockAsyncReplicationPolicyId(dpBlockAsyncReplicationPolicyId int64) ApiListDpBlockAsyncReplicationPairRequest {
	r.dpBlockAsyncReplicationPolicyId = &dpBlockAsyncReplicationPolicyId
	return r
}

func (r ApiListDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairsResp, *http.Response, error) {
	return r.ApiService.ListDpBlockAsyncReplicationPairExecute(r)
}

/*
ListDpBlockAsyncReplicationPair Method for ListDpBlockAsyncReplicationPair

List dp block async replication pairs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) ListDpBlockAsyncReplicationPair(ctx context.Context) ApiListDpBlockAsyncReplicationPairRequest {
	return ApiListDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairsResp
func (a *DpBlockAsyncReplicationPairsAPIService) ListDpBlockAsyncReplicationPairExecute(r ApiListDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.ListDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.blockVolumeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "block_volume_id", r.blockVolumeId, "form", "")
	}
	if r.dpBlockAsyncReplicationPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp_block_async_replication_policy_id", r.dpBlockAsyncReplicationPolicyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
}

func (r ApiPauseDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.PauseDpBlockAsyncReplicationPairExecute(r)
}

/*
PauseDpBlockAsyncReplicationPair Method for PauseDpBlockAsyncReplicationPair

pause periodic sync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiPauseDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) PauseDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiPauseDpBlockAsyncReplicationPairRequest {
	return ApiPauseDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) PauseDpBlockAsyncReplicationPairExecute(r ApiPauseDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.PauseDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}:pause"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
}

func (r ApiResumeDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.ResumeDpBlockAsyncReplicationPairExecute(r)
}

/*
ResumeDpBlockAsyncReplicationPair Method for ResumeDpBlockAsyncReplicationPair

resume periodic sync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiResumeDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) ResumeDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiResumeDpBlockAsyncReplicationPairRequest {
	return ApiResumeDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) ResumeDpBlockAsyncReplicationPairExecute(r ApiResumeDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.ResumeDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}:resume"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRollbackDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
}

func (r ApiRollbackDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.RollbackDpBlockAsyncReplicationPairExecute(r)
}

/*
RollbackDpBlockAsyncReplicationPair Method for RollbackDpBlockAsyncReplicationPair

rollback volume snapshot pair to previous snapshot

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiRollbackDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) RollbackDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiRollbackDpBlockAsyncReplicationPairRequest {
	return ApiRollbackDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) RollbackDpBlockAsyncReplicationPairExecute(r ApiRollbackDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.RollbackDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}:rollback"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSyncDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
}

func (r ApiSyncDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.SyncDpBlockAsyncReplicationPairExecute(r)
}

/*
SyncDpBlockAsyncReplicationPair Method for SyncDpBlockAsyncReplicationPair

sync pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiSyncDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) SyncDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiSyncDpBlockAsyncReplicationPairRequest {
	return ApiSyncDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) SyncDpBlockAsyncReplicationPairExecute(r ApiSyncDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.SyncDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}:sync"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSyncFailoverDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
}

func (r ApiSyncFailoverDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.SyncFailoverDpBlockAsyncReplicationPairExecute(r)
}

/*
SyncFailoverDpBlockAsyncReplicationPair Method for SyncFailoverDpBlockAsyncReplicationPair

switch the roles of the pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiSyncFailoverDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) SyncFailoverDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiSyncFailoverDpBlockAsyncReplicationPairRequest {
	return ApiSyncFailoverDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) SyncFailoverDpBlockAsyncReplicationPairExecute(r ApiSyncFailoverDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.SyncFailoverDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}:sync-failover"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDpBlockAsyncReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpBlockAsyncReplicationPairsAPIService
	pairId int64
	body *DpBlockAsyncReplicationPairUpdateReq
}

// pair info
func (r ApiUpdateDpBlockAsyncReplicationPairRequest) Body(body DpBlockAsyncReplicationPairUpdateReq) ApiUpdateDpBlockAsyncReplicationPairRequest {
	r.body = &body
	return r
}

func (r ApiUpdateDpBlockAsyncReplicationPairRequest) Execute() (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	return r.ApiService.UpdateDpBlockAsyncReplicationPairExecute(r)
}

/*
UpdateDpBlockAsyncReplicationPair Method for UpdateDpBlockAsyncReplicationPair

Update dp block async replication pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiUpdateDpBlockAsyncReplicationPairRequest
*/
func (a *DpBlockAsyncReplicationPairsAPIService) UpdateDpBlockAsyncReplicationPair(ctx context.Context, pairId int64) ApiUpdateDpBlockAsyncReplicationPairRequest {
	return ApiUpdateDpBlockAsyncReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpBlockAsyncReplicationPairResp
func (a *DpBlockAsyncReplicationPairsAPIService) UpdateDpBlockAsyncReplicationPairExecute(r ApiUpdateDpBlockAsyncReplicationPairRequest) (*DpBlockAsyncReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpBlockAsyncReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpBlockAsyncReplicationPairsAPIService.UpdateDpBlockAsyncReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-block-async-replication-pairs/{pair_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
