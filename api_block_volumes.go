/*
XMS API

XMS is the controller of distributed storage system

API version: XSCALEROS_6.4.000.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BlockVolumesAPIService BlockVolumesAPI service
type BlockVolumesAPIService service

type ApiBatchGetBlockVolumeSamplesRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	ids *string
	durationBegin *string
	durationEnd *string
	period *string
}

// volume ids; example: id1,id2,id3
func (r ApiBatchGetBlockVolumeSamplesRequest) Ids(ids string) ApiBatchGetBlockVolumeSamplesRequest {
	r.ids = &ids
	return r
}

// duration begin timestamp
func (r ApiBatchGetBlockVolumeSamplesRequest) DurationBegin(durationBegin string) ApiBatchGetBlockVolumeSamplesRequest {
	r.durationBegin = &durationBegin
	return r
}

// duration end timestamp
func (r ApiBatchGetBlockVolumeSamplesRequest) DurationEnd(durationEnd string) ApiBatchGetBlockVolumeSamplesRequest {
	r.durationEnd = &durationEnd
	return r
}

// samples period
func (r ApiBatchGetBlockVolumeSamplesRequest) Period(period string) ApiBatchGetBlockVolumeSamplesRequest {
	r.period = &period
	return r
}

func (r ApiBatchGetBlockVolumeSamplesRequest) Execute() (*MultiVolumesSamplesResp, *http.Response, error) {
	return r.ApiService.BatchGetBlockVolumeSamplesExecute(r)
}

/*
BatchGetBlockVolumeSamples Method for BatchGetBlockVolumeSamples

Get samples of multiple block volumes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchGetBlockVolumeSamplesRequest
*/
func (a *BlockVolumesAPIService) BatchGetBlockVolumeSamples(ctx context.Context) ApiBatchGetBlockVolumeSamplesRequest {
	return ApiBatchGetBlockVolumeSamplesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MultiVolumesSamplesResp
func (a *BlockVolumesAPIService) BatchGetBlockVolumeSamplesExecute(r ApiBatchGetBlockVolumeSamplesRequest) (*MultiVolumesSamplesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MultiVolumesSamplesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.BatchGetBlockVolumeSamples")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/samples"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	if r.durationBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_begin", r.durationBegin, "form", "")
	}
	if r.durationEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_end", r.durationEnd, "form", "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBlockVolumeRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	body *VolumeCreateReq
}

// volume info
func (r ApiCreateBlockVolumeRequest) Body(body VolumeCreateReq) ApiCreateBlockVolumeRequest {
	r.body = &body
	return r
}

func (r ApiCreateBlockVolumeRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.CreateBlockVolumeExecute(r)
}

/*
CreateBlockVolume Method for CreateBlockVolume

Create block volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBlockVolumeRequest
*/
func (a *BlockVolumesAPIService) CreateBlockVolume(ctx context.Context) ApiCreateBlockVolumeRequest {
	return ApiCreateBlockVolumeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) CreateBlockVolumeExecute(r ApiCreateBlockVolumeRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.CreateBlockVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBlockVolumeRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	bypassTrash *bool
}

// bypass trash or not
func (r ApiDeleteBlockVolumeRequest) BypassTrash(bypassTrash bool) ApiDeleteBlockVolumeRequest {
	r.bypassTrash = &bypassTrash
	return r
}

func (r ApiDeleteBlockVolumeRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.DeleteBlockVolumeExecute(r)
}

/*
DeleteBlockVolume Method for DeleteBlockVolume

Delete block volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId volume id
 @return ApiDeleteBlockVolumeRequest
*/
func (a *BlockVolumesAPIService) DeleteBlockVolume(ctx context.Context, blockVolumeId int64) ApiDeleteBlockVolumeRequest {
	return ApiDeleteBlockVolumeRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) DeleteBlockVolumeExecute(r ApiDeleteBlockVolumeRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.DeleteBlockVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bypassTrash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bypass_trash", r.bypassTrash, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockVolumeRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
}

func (r ApiGetBlockVolumeRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.GetBlockVolumeExecute(r)
}

/*
GetBlockVolume Method for GetBlockVolume

get a block volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId block volume id
 @return ApiGetBlockVolumeRequest
*/
func (a *BlockVolumesAPIService) GetBlockVolume(ctx context.Context, blockVolumeId int64) ApiGetBlockVolumeRequest {
	return ApiGetBlockVolumeRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) GetBlockVolumeExecute(r ApiGetBlockVolumeRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.GetBlockVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBlockVolumeSamplesRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	durationBegin *string
	durationEnd *string
	period *string
}

// duration begin timestamp
func (r ApiGetBlockVolumeSamplesRequest) DurationBegin(durationBegin string) ApiGetBlockVolumeSamplesRequest {
	r.durationBegin = &durationBegin
	return r
}

// duration end timestamp
func (r ApiGetBlockVolumeSamplesRequest) DurationEnd(durationEnd string) ApiGetBlockVolumeSamplesRequest {
	r.durationEnd = &durationEnd
	return r
}

// samples period
func (r ApiGetBlockVolumeSamplesRequest) Period(period string) ApiGetBlockVolumeSamplesRequest {
	r.period = &period
	return r
}

func (r ApiGetBlockVolumeSamplesRequest) Execute() (*VolumeSamplesResp, *http.Response, error) {
	return r.ApiService.GetBlockVolumeSamplesExecute(r)
}

/*
GetBlockVolumeSamples Method for GetBlockVolumeSamples

get a block volume's Samples

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId block volume id
 @return ApiGetBlockVolumeSamplesRequest
*/
func (a *BlockVolumesAPIService) GetBlockVolumeSamples(ctx context.Context, blockVolumeId int64) ApiGetBlockVolumeSamplesRequest {
	return ApiGetBlockVolumeSamplesRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeSamplesResp
func (a *BlockVolumesAPIService) GetBlockVolumeSamplesExecute(r ApiGetBlockVolumeSamplesRequest) (*VolumeSamplesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeSamplesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.GetBlockVolumeSamples")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}/samples"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.durationBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_begin", r.durationBegin, "form", "")
	}
	if r.durationEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration_end", r.durationEnd, "form", "")
	}
	if r.period != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "period", r.period, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBlockVolumesRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	limit *int64
	offset *int64
	poolId *int64
	poolName *string
	clusterId *string
	blockSnapshotId *int64
	name *string
	namePrefix *string
	volumeName *string
	uid *string
	clientGroupId *int64
	mappingGroupId *int64
	excludeMappingGroupId *int64
	accessPathId *int64
	passive *bool
	recycled *bool
	status *string
	withNotUsed *bool
	q *string
	sort *string
	all *bool
	dpBlockBackupPolicyId *int64
	dpBlockAsyncReplicationPolicyId *int64
	couldHaveIo *bool
	rbdClientId *int64
}

// paging param
func (r ApiListBlockVolumesRequest) Limit(limit int64) ApiListBlockVolumesRequest {
	r.limit = &limit
	return r
}

// paging param
func (r ApiListBlockVolumesRequest) Offset(offset int64) ApiListBlockVolumesRequest {
	r.offset = &offset
	return r
}

// The id of the pool volumes belong to
func (r ApiListBlockVolumesRequest) PoolId(poolId int64) ApiListBlockVolumesRequest {
	r.poolId = &poolId
	return r
}

// The pool_name of the pool volumes belong to
func (r ApiListBlockVolumesRequest) PoolName(poolName string) ApiListBlockVolumesRequest {
	r.poolName = &poolName
	return r
}

// cluster id
func (r ApiListBlockVolumesRequest) ClusterId(clusterId string) ApiListBlockVolumesRequest {
	r.clusterId = &clusterId
	return r
}

// related snapshot id
func (r ApiListBlockVolumesRequest) BlockSnapshotId(blockSnapshotId int64) ApiListBlockVolumesRequest {
	r.blockSnapshotId = &blockSnapshotId
	return r
}

// name of volume
func (r ApiListBlockVolumesRequest) Name(name string) ApiListBlockVolumesRequest {
	r.name = &name
	return r
}

// name prefix of volume
func (r ApiListBlockVolumesRequest) NamePrefix(namePrefix string) ApiListBlockVolumesRequest {
	r.namePrefix = &namePrefix
	return r
}

// volume_name of volume
func (r ApiListBlockVolumesRequest) VolumeName(volumeName string) ApiListBlockVolumesRequest {
	r.volumeName = &volumeName
	return r
}

// uid of volume
func (r ApiListBlockVolumesRequest) Uid(uid string) ApiListBlockVolumesRequest {
	r.uid = &uid
	return r
}

// related client group id
func (r ApiListBlockVolumesRequest) ClientGroupId(clientGroupId int64) ApiListBlockVolumesRequest {
	r.clientGroupId = &clientGroupId
	return r
}

// related mapping group id
func (r ApiListBlockVolumesRequest) MappingGroupId(mappingGroupId int64) ApiListBlockVolumesRequest {
	r.mappingGroupId = &mappingGroupId
	return r
}

// exclude mapping group id, with access path id
func (r ApiListBlockVolumesRequest) ExcludeMappingGroupId(excludeMappingGroupId int64) ApiListBlockVolumesRequest {
	r.excludeMappingGroupId = &excludeMappingGroupId
	return r
}

// related access path id
func (r ApiListBlockVolumesRequest) AccessPathId(accessPathId int64) ApiListBlockVolumesRequest {
	r.accessPathId = &accessPathId
	return r
}

// passive or not
func (r ApiListBlockVolumesRequest) Passive(passive bool) ApiListBlockVolumesRequest {
	r.passive = &passive
	return r
}

// recycled or not
func (r ApiListBlockVolumesRequest) Recycled(recycled bool) ApiListBlockVolumesRequest {
	r.recycled = &recycled
	return r
}

// filter with status
func (r ApiListBlockVolumesRequest) Status(status string) ApiListBlockVolumesRequest {
	r.status = &status
	return r
}

// list with not used volumes, can be used with access path id
func (r ApiListBlockVolumesRequest) WithNotUsed(withNotUsed bool) ApiListBlockVolumesRequest {
	r.withNotUsed = &withNotUsed
	return r
}

// query param of search
func (r ApiListBlockVolumesRequest) Q(q string) ApiListBlockVolumesRequest {
	r.q = &q
	return r
}

// sort param of search
func (r ApiListBlockVolumesRequest) Sort(sort string) ApiListBlockVolumesRequest {
	r.sort = &sort
	return r
}

// show all volumes
func (r ApiListBlockVolumesRequest) All(all bool) ApiListBlockVolumesRequest {
	r.all = &all
	return r
}

// show volumes of specific dp block backup policy
func (r ApiListBlockVolumesRequest) DpBlockBackupPolicyId(dpBlockBackupPolicyId int64) ApiListBlockVolumesRequest {
	r.dpBlockBackupPolicyId = &dpBlockBackupPolicyId
	return r
}

// show volumes of specific dp block async replication policy
func (r ApiListBlockVolumesRequest) DpBlockAsyncReplicationPolicyId(dpBlockAsyncReplicationPolicyId int64) ApiListBlockVolumesRequest {
	r.dpBlockAsyncReplicationPolicyId = &dpBlockAsyncReplicationPolicyId
	return r
}

// show volumes without volume that cannot have io
func (r ApiListBlockVolumesRequest) CouldHaveIo(couldHaveIo bool) ApiListBlockVolumesRequest {
	r.couldHaveIo = &couldHaveIo
	return r
}

// rbd client id
func (r ApiListBlockVolumesRequest) RbdClientId(rbdClientId int64) ApiListBlockVolumesRequest {
	r.rbdClientId = &rbdClientId
	return r
}

func (r ApiListBlockVolumesRequest) Execute() (*VolumesResp, *http.Response, error) {
	return r.ApiService.ListBlockVolumesExecute(r)
}

/*
ListBlockVolumes Method for ListBlockVolumes

List block volumes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBlockVolumesRequest
*/
func (a *BlockVolumesAPIService) ListBlockVolumes(ctx context.Context) ApiListBlockVolumesRequest {
	return ApiListBlockVolumesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VolumesResp
func (a *BlockVolumesAPIService) ListBlockVolumesExecute(r ApiListBlockVolumesRequest) (*VolumesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.ListBlockVolumes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.poolId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pool_id", r.poolId, "form", "")
	}
	if r.poolName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pool_name", r.poolName, "form", "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	if r.blockSnapshotId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "block_snapshot_id", r.blockSnapshotId, "form", "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "form", "")
	}
	if r.namePrefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name_prefix", r.namePrefix, "form", "")
	}
	if r.volumeName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "volume_name", r.volumeName, "form", "")
	}
	if r.uid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uid", r.uid, "form", "")
	}
	if r.clientGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "client_group_id", r.clientGroupId, "form", "")
	}
	if r.mappingGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mapping_group_id", r.mappingGroupId, "form", "")
	}
	if r.excludeMappingGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_mapping_group_id", r.excludeMappingGroupId, "form", "")
	}
	if r.accessPathId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "access_path_id", r.accessPathId, "form", "")
	}
	if r.passive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "passive", r.passive, "form", "")
	}
	if r.recycled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recycled", r.recycled, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.withNotUsed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "with_not_used", r.withNotUsed, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.all != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "all", r.all, "form", "")
	}
	if r.dpBlockBackupPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp_block_backup_policy_id", r.dpBlockBackupPolicyId, "form", "")
	}
	if r.dpBlockAsyncReplicationPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp_block_async_replication_policy_id", r.dpBlockAsyncReplicationPolicyId, "form", "")
	}
	if r.couldHaveIo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "could_have_io", r.couldHaveIo, "form", "")
	}
	if r.rbdClientId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rbd_client_id", r.rbdClientId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMigrateBlockVolumeRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	body *VolumeMigrateReq
}

// volume migration info
func (r ApiMigrateBlockVolumeRequest) Body(body VolumeMigrateReq) ApiMigrateBlockVolumeRequest {
	r.body = &body
	return r
}

func (r ApiMigrateBlockVolumeRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.MigrateBlockVolumeExecute(r)
}

/*
MigrateBlockVolume Method for MigrateBlockVolume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId the block volume id
 @return ApiMigrateBlockVolumeRequest
*/
func (a *BlockVolumesAPIService) MigrateBlockVolume(ctx context.Context, blockVolumeId int64) ApiMigrateBlockVolumeRequest {
	return ApiMigrateBlockVolumeRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) MigrateBlockVolumeExecute(r ApiMigrateBlockVolumeRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.MigrateBlockVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:migrate"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRebuildBlockVolumeReplicationRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	force *bool
}

// force rebuild or not
func (r ApiRebuildBlockVolumeReplicationRequest) Force(force bool) ApiRebuildBlockVolumeReplicationRequest {
	r.force = &force
	return r
}

func (r ApiRebuildBlockVolumeReplicationRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.RebuildBlockVolumeReplicationExecute(r)
}

/*
RebuildBlockVolumeReplication Method for RebuildBlockVolumeReplication

Rebuild block volume replication

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId block volume id
 @return ApiRebuildBlockVolumeReplicationRequest
*/
func (a *BlockVolumesAPIService) RebuildBlockVolumeReplication(ctx context.Context, blockVolumeId int64) ApiRebuildBlockVolumeReplicationRequest {
	return ApiRebuildBlockVolumeReplicationRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) RebuildBlockVolumeReplicationExecute(r ApiRebuildBlockVolumeReplicationRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.RebuildBlockVolumeReplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:rebuild-replication"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetAsyncReplicationProtectionRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	body *VolumeAsyncReplicationProtectionReq
}

// request info
func (r ApiSetAsyncReplicationProtectionRequest) Body(body VolumeAsyncReplicationProtectionReq) ApiSetAsyncReplicationProtectionRequest {
	r.body = &body
	return r
}

func (r ApiSetAsyncReplicationProtectionRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.SetAsyncReplicationProtectionExecute(r)
}

/*
SetAsyncReplicationProtection Method for SetAsyncReplicationProtection

Set async replication protection for a block volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId the block volume id
 @return ApiSetAsyncReplicationProtectionRequest
*/
func (a *BlockVolumesAPIService) SetAsyncReplicationProtection(ctx context.Context, blockVolumeId int64) ApiSetAsyncReplicationProtectionRequest {
	return ApiSetAsyncReplicationProtectionRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) SetAsyncReplicationProtectionExecute(r ApiSetAsyncReplicationProtectionRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.SetAsyncReplicationProtection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:set-async-replication-protection"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetBackupProtectionRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	body *VolumeBackupProtectionReq
}

// request info
func (r ApiSetBackupProtectionRequest) Body(body VolumeBackupProtectionReq) ApiSetBackupProtectionRequest {
	r.body = &body
	return r
}

func (r ApiSetBackupProtectionRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.SetBackupProtectionExecute(r)
}

/*
SetBackupProtection Method for SetBackupProtection

Set backup protection for a block volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId the block volume id
 @return ApiSetBackupProtectionRequest
*/
func (a *BlockVolumesAPIService) SetBackupProtection(ctx context.Context, blockVolumeId int64) ApiSetBackupProtectionRequest {
	return ApiSetBackupProtectionRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) SetBackupProtectionExecute(r ApiSetBackupProtectionRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.SetBackupProtection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:set-backup-protection"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetBlockVolumeCrcRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	body *VolumeCrcSetReq
}

// volume crc info
func (r ApiSetBlockVolumeCrcRequest) Body(body VolumeCrcSetReq) ApiSetBlockVolumeCrcRequest {
	r.body = &body
	return r
}

func (r ApiSetBlockVolumeCrcRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.SetBlockVolumeCrcExecute(r)
}

/*
SetBlockVolumeCrc Method for SetBlockVolumeCrc

Set block volume crc

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId block volume id
 @return ApiSetBlockVolumeCrcRequest
*/
func (a *BlockVolumesAPIService) SetBlockVolumeCrc(ctx context.Context, blockVolumeId int64) ApiSetBlockVolumeCrcRequest {
	return ApiSetBlockVolumeCrcRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) SetBlockVolumeCrcExecute(r ApiSetBlockVolumeCrcRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.SetBlockVolumeCrc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:set-crc"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetBlockVolumeReplicationRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	body *VolumeReplicationSetReq
}

// volume replication info
func (r ApiSetBlockVolumeReplicationRequest) Body(body VolumeReplicationSetReq) ApiSetBlockVolumeReplicationRequest {
	r.body = &body
	return r
}

func (r ApiSetBlockVolumeReplicationRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.SetBlockVolumeReplicationExecute(r)
}

/*
SetBlockVolumeReplication Method for SetBlockVolumeReplication

Set block volume replication

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId block volume id
 @return ApiSetBlockVolumeReplicationRequest
*/
func (a *BlockVolumesAPIService) SetBlockVolumeReplication(ctx context.Context, blockVolumeId int64) ApiSetBlockVolumeReplicationRequest {
	return ApiSetBlockVolumeReplicationRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) SetBlockVolumeReplicationExecute(r ApiSetBlockVolumeReplicationRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.SetBlockVolumeReplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:set-replication"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetSnapshotProtectionRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	body *VolumeSnapshotProtectionReq
}

// request info
func (r ApiSetSnapshotProtectionRequest) Body(body VolumeSnapshotProtectionReq) ApiSetSnapshotProtectionRequest {
	r.body = &body
	return r
}

func (r ApiSetSnapshotProtectionRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.SetSnapshotProtectionExecute(r)
}

/*
SetSnapshotProtection Method for SetSnapshotProtection

Set snapshot protection for a block volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId the block volume id
 @return ApiSetSnapshotProtectionRequest
*/
func (a *BlockVolumesAPIService) SetSnapshotProtection(ctx context.Context, blockVolumeId int64) ApiSetSnapshotProtectionRequest {
	return ApiSetSnapshotProtectionRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) SetSnapshotProtectionExecute(r ApiSetSnapshotProtectionRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.SetSnapshotProtection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:set-snapshot-protection"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSuspendBlockVolumeReplicationRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
}

func (r ApiSuspendBlockVolumeReplicationRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.SuspendBlockVolumeReplicationExecute(r)
}

/*
SuspendBlockVolumeReplication Method for SuspendBlockVolumeReplication

Suspend block volume replication

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId block volume id
 @return ApiSuspendBlockVolumeReplicationRequest
*/
func (a *BlockVolumesAPIService) SuspendBlockVolumeReplication(ctx context.Context, blockVolumeId int64) ApiSuspendBlockVolumeReplicationRequest {
	return ApiSuspendBlockVolumeReplicationRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) SuspendBlockVolumeReplicationExecute(r ApiSuspendBlockVolumeReplicationRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.SuspendBlockVolumeReplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:suspend-replication"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsetAsyncReplicationProtectionRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	force *bool
	reserveVolume *bool
}

// force unset or not
func (r ApiUnsetAsyncReplicationProtectionRequest) Force(force bool) ApiUnsetAsyncReplicationProtectionRequest {
	r.force = &force
	return r
}

// reserve replicated volume or not
func (r ApiUnsetAsyncReplicationProtectionRequest) ReserveVolume(reserveVolume bool) ApiUnsetAsyncReplicationProtectionRequest {
	r.reserveVolume = &reserveVolume
	return r
}

func (r ApiUnsetAsyncReplicationProtectionRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.UnsetAsyncReplicationProtectionExecute(r)
}

/*
UnsetAsyncReplicationProtection Method for UnsetAsyncReplicationProtection

Unset async replication protection for a block volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId the block volume id
 @return ApiUnsetAsyncReplicationProtectionRequest
*/
func (a *BlockVolumesAPIService) UnsetAsyncReplicationProtection(ctx context.Context, blockVolumeId int64) ApiUnsetAsyncReplicationProtectionRequest {
	return ApiUnsetAsyncReplicationProtectionRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) UnsetAsyncReplicationProtectionExecute(r ApiUnsetAsyncReplicationProtectionRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.UnsetAsyncReplicationProtection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:unset-async-replication-protection"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	if r.reserveVolume != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "reserve_volume", r.reserveVolume, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsetBackupProtectionRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	force *bool
}

// force unset or not
func (r ApiUnsetBackupProtectionRequest) Force(force bool) ApiUnsetBackupProtectionRequest {
	r.force = &force
	return r
}

func (r ApiUnsetBackupProtectionRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.UnsetBackupProtectionExecute(r)
}

/*
UnsetBackupProtection Method for UnsetBackupProtection

Unset backup protection for a block volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId the block volume id
 @return ApiUnsetBackupProtectionRequest
*/
func (a *BlockVolumesAPIService) UnsetBackupProtection(ctx context.Context, blockVolumeId int64) ApiUnsetBackupProtectionRequest {
	return ApiUnsetBackupProtectionRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) UnsetBackupProtectionExecute(r ApiUnsetBackupProtectionRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.UnsetBackupProtection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:unset-backup-protection"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsetBlockVolumeCrcRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	body *VolumeCrcSetReq
}

// volume crc info
func (r ApiUnsetBlockVolumeCrcRequest) Body(body VolumeCrcSetReq) ApiUnsetBlockVolumeCrcRequest {
	r.body = &body
	return r
}

func (r ApiUnsetBlockVolumeCrcRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.UnsetBlockVolumeCrcExecute(r)
}

/*
UnsetBlockVolumeCrc Method for UnsetBlockVolumeCrc

Unset block volume crc

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId block volume id
 @return ApiUnsetBlockVolumeCrcRequest
*/
func (a *BlockVolumesAPIService) UnsetBlockVolumeCrc(ctx context.Context, blockVolumeId int64) ApiUnsetBlockVolumeCrcRequest {
	return ApiUnsetBlockVolumeCrcRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) UnsetBlockVolumeCrcExecute(r ApiUnsetBlockVolumeCrcRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.UnsetBlockVolumeCrc")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:unset-crc"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsetBlockVolumeReplicationRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
}

func (r ApiUnsetBlockVolumeReplicationRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.UnsetBlockVolumeReplicationExecute(r)
}

/*
UnsetBlockVolumeReplication Method for UnsetBlockVolumeReplication

Unset block volume replication

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId block volume id
 @return ApiUnsetBlockVolumeReplicationRequest
*/
func (a *BlockVolumesAPIService) UnsetBlockVolumeReplication(ctx context.Context, blockVolumeId int64) ApiUnsetBlockVolumeReplicationRequest {
	return ApiUnsetBlockVolumeReplicationRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) UnsetBlockVolumeReplicationExecute(r ApiUnsetBlockVolumeReplicationRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.UnsetBlockVolumeReplication")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:unset-replication"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnsetSnapshotProtectionRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	force *bool
}

// force unset or not
func (r ApiUnsetSnapshotProtectionRequest) Force(force bool) ApiUnsetSnapshotProtectionRequest {
	r.force = &force
	return r
}

func (r ApiUnsetSnapshotProtectionRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.UnsetSnapshotProtectionExecute(r)
}

/*
UnsetSnapshotProtection Method for UnsetSnapshotProtection

Unset snapshot protection for a block volume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId the block volume id
 @return ApiUnsetSnapshotProtectionRequest
*/
func (a *BlockVolumesAPIService) UnsetSnapshotProtection(ctx context.Context, blockVolumeId int64) ApiUnsetSnapshotProtectionRequest {
	return ApiUnsetSnapshotProtectionRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) UnsetSnapshotProtectionExecute(r ApiUnsetSnapshotProtectionRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.UnsetSnapshotProtection")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:unset-snapshot-protection"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBlockVolumeRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	body *VolumeUpdateReq
}

// volume info
func (r ApiUpdateBlockVolumeRequest) Body(body VolumeUpdateReq) ApiUpdateBlockVolumeRequest {
	r.body = &body
	return r
}

func (r ApiUpdateBlockVolumeRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.UpdateBlockVolumeExecute(r)
}

/*
UpdateBlockVolume Method for UpdateBlockVolume

Update block volume info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId the block volume id
 @return ApiUpdateBlockVolumeRequest
*/
func (a *BlockVolumesAPIService) UpdateBlockVolume(ctx context.Context, blockVolumeId int64) ApiUpdateBlockVolumeRequest {
	return ApiUpdateBlockVolumeRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) UpdateBlockVolumeExecute(r ApiUpdateBlockVolumeRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.UpdateBlockVolume")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBlockVolumeVolumeNameRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	blockVolumeId int64
	body *VolumeUpdateVolumeNameReq
}

// volume volume_name
func (r ApiUpdateBlockVolumeVolumeNameRequest) Body(body VolumeUpdateVolumeNameReq) ApiUpdateBlockVolumeVolumeNameRequest {
	r.body = &body
	return r
}

func (r ApiUpdateBlockVolumeVolumeNameRequest) Execute() (*VolumeResp, *http.Response, error) {
	return r.ApiService.UpdateBlockVolumeVolumeNameExecute(r)
}

/*
UpdateBlockVolumeVolumeName Method for UpdateBlockVolumeVolumeName

Update block volume volume_name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param blockVolumeId the block volume id
 @return ApiUpdateBlockVolumeVolumeNameRequest
*/
func (a *BlockVolumesAPIService) UpdateBlockVolumeVolumeName(ctx context.Context, blockVolumeId int64) ApiUpdateBlockVolumeVolumeNameRequest {
	return ApiUpdateBlockVolumeVolumeNameRequest{
		ApiService: a,
		ctx: ctx,
		blockVolumeId: blockVolumeId,
	}
}

// Execute executes the request
//  @return VolumeResp
func (a *BlockVolumesAPIService) UpdateBlockVolumeVolumeNameExecute(r ApiUpdateBlockVolumeVolumeNameRequest) (*VolumeResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VolumeResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.UpdateBlockVolumeVolumeName")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/{block_volume_id}:update-volume-name"
	localVarPath = strings.Replace(localVarPath, "{"+"block_volume_id"+"}", url.PathEscape(parameterValueToString(r.blockVolumeId, "blockVolumeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateVolumeStatRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	body *UpdateVolumeStatReq
}

// volume stat
func (r ApiUpdateVolumeStatRequest) Body(body UpdateVolumeStatReq) ApiUpdateVolumeStatRequest {
	r.body = &body
	return r
}

func (r ApiUpdateVolumeStatRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVolumeStatExecute(r)
}

/*
UpdateVolumeStat Method for UpdateVolumeStat

update volume stat from other cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateVolumeStatRequest
*/
func (a *BlockVolumesAPIService) UpdateVolumeStat(ctx context.Context) ApiUpdateVolumeStatRequest {
	return ApiUpdateVolumeStatRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BlockVolumesAPIService) UpdateVolumeStatExecute(r ApiUpdateVolumeStatRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.UpdateVolumeStat")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/:update-stat"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateVolumeStatsRequest struct {
	ctx context.Context
	ApiService *BlockVolumesAPIService
	body *UpdateVolumeStatsReq
}

// volume stats
func (r ApiUpdateVolumeStatsRequest) Body(body UpdateVolumeStatsReq) ApiUpdateVolumeStatsRequest {
	r.body = &body
	return r
}

func (r ApiUpdateVolumeStatsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateVolumeStatsExecute(r)
}

/*
UpdateVolumeStats Method for UpdateVolumeStats

update volume stats from other cluster

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateVolumeStatsRequest
*/
func (a *BlockVolumesAPIService) UpdateVolumeStats(ctx context.Context) ApiUpdateVolumeStatsRequest {
	return ApiUpdateVolumeStatsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *BlockVolumesAPIService) UpdateVolumeStatsExecute(r ApiUpdateVolumeStatsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BlockVolumesAPIService.UpdateVolumeStats")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/block-volumes/:update-stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
