/*
XMS API

XMS is the controller of distributed storage system

API version: XSCALEROS_6.4.000.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AlertInfosAPIService AlertInfosAPI service
type AlertInfosAPIService service

type ApiAckAlertInfoRequest struct {
	ctx context.Context
	ApiService *AlertInfosAPIService
	alertInfoId int64
}

func (r ApiAckAlertInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.AckAlertInfoExecute(r)
}

/*
AckAlertInfo Method for AckAlertInfo

set the acked status of alert info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertInfoId the id of alert info
 @return ApiAckAlertInfoRequest
*/
func (a *AlertInfosAPIService) AckAlertInfo(ctx context.Context, alertInfoId int64) ApiAckAlertInfoRequest {
	return ApiAckAlertInfoRequest{
		ApiService: a,
		ctx: ctx,
		alertInfoId: alertInfoId,
	}
}

// Execute executes the request
func (a *AlertInfosAPIService) AckAlertInfoExecute(r ApiAckAlertInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertInfosAPIService.AckAlertInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alert-infos/{alert_info_id}:ack"
	localVarPath = strings.Replace(localVarPath, "{"+"alert_info_id"+"}", url.PathEscape(parameterValueToString(r.alertInfoId, "alertInfoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountAlertInfosRequest struct {
	ctx context.Context
	ApiService *AlertInfosAPIService
	acked *bool
	resolved *bool
	resourceType *string
	resourceId *int64
}

// acked of alert info
func (r ApiCountAlertInfosRequest) Acked(acked bool) ApiCountAlertInfosRequest {
	r.acked = &acked
	return r
}

// resolved or not of alert info
func (r ApiCountAlertInfosRequest) Resolved(resolved bool) ApiCountAlertInfosRequest {
	r.resolved = &resolved
	return r
}

// resource type of alert info
func (r ApiCountAlertInfosRequest) ResourceType(resourceType string) ApiCountAlertInfosRequest {
	r.resourceType = &resourceType
	return r
}

// resource id of alert info
func (r ApiCountAlertInfosRequest) ResourceId(resourceId int64) ApiCountAlertInfosRequest {
	r.resourceId = &resourceId
	return r
}

func (r ApiCountAlertInfosRequest) Execute() (*AlertStatsResp, *http.Response, error) {
	return r.ApiService.CountAlertInfosExecute(r)
}

/*
CountAlertInfos Method for CountAlertInfos

count all alert infos

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountAlertInfosRequest
*/
func (a *AlertInfosAPIService) CountAlertInfos(ctx context.Context) ApiCountAlertInfosRequest {
	return ApiCountAlertInfosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertStatsResp
func (a *AlertInfosAPIService) CountAlertInfosExecute(r ApiCountAlertInfosRequest) (*AlertStatsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertStatsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertInfosAPIService.CountAlertInfos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alert-infos/stats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.acked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acked", r.acked, "form", "")
	}
	if r.resolved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolved", r.resolved, "form", "")
	}
	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource_type", r.resourceType, "form", "")
	}
	if r.resourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource_id", r.resourceId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountBatchDeleteAlertInfosRequest struct {
	ctx context.Context
	ApiService *AlertInfosAPIService
	createAfter *string
	createBefore *string
	clusterId *string
}

// create_after timestamp of alert info
func (r ApiCountBatchDeleteAlertInfosRequest) CreateAfter(createAfter string) ApiCountBatchDeleteAlertInfosRequest {
	r.createAfter = &createAfter
	return r
}

// create_before end time of alert info
func (r ApiCountBatchDeleteAlertInfosRequest) CreateBefore(createBefore string) ApiCountBatchDeleteAlertInfosRequest {
	r.createBefore = &createBefore
	return r
}

// cluster id
func (r ApiCountBatchDeleteAlertInfosRequest) ClusterId(clusterId string) ApiCountBatchDeleteAlertInfosRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiCountBatchDeleteAlertInfosRequest) Execute() (*AlertInfoBatchDeleteResp, *http.Response, error) {
	return r.ApiService.CountBatchDeleteAlertInfosExecute(r)
}

/*
CountBatchDeleteAlertInfos Method for CountBatchDeleteAlertInfos

Return info of batch delete alert infos

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCountBatchDeleteAlertInfosRequest
*/
func (a *AlertInfosAPIService) CountBatchDeleteAlertInfos(ctx context.Context) ApiCountBatchDeleteAlertInfosRequest {
	return ApiCountBatchDeleteAlertInfosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertInfoBatchDeleteResp
func (a *AlertInfosAPIService) CountBatchDeleteAlertInfosExecute(r ApiCountBatchDeleteAlertInfosRequest) (*AlertInfoBatchDeleteResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertInfoBatchDeleteResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertInfosAPIService.CountBatchDeleteAlertInfos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alert-infos/batch-delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create_after", r.createAfter, "form", "")
	}
	if r.createBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create_before", r.createBefore, "form", "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAlertInfoRequest struct {
	ctx context.Context
	ApiService *AlertInfosAPIService
	alertInfoId int64
}

func (r ApiDeleteAlertInfoRequest) Execute() (*AlertInfoResp, *http.Response, error) {
	return r.ApiService.DeleteAlertInfoExecute(r)
}

/*
DeleteAlertInfo Method for DeleteAlertInfo

delete an alert info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertInfoId the id of alert info
 @return ApiDeleteAlertInfoRequest
*/
func (a *AlertInfosAPIService) DeleteAlertInfo(ctx context.Context, alertInfoId int64) ApiDeleteAlertInfoRequest {
	return ApiDeleteAlertInfoRequest{
		ApiService: a,
		ctx: ctx,
		alertInfoId: alertInfoId,
	}
}

// Execute executes the request
//  @return AlertInfoResp
func (a *AlertInfosAPIService) DeleteAlertInfoExecute(r ApiDeleteAlertInfoRequest) (*AlertInfoResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertInfoResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertInfosAPIService.DeleteAlertInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alert-infos/{alert_info_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"alert_info_id"+"}", url.PathEscape(parameterValueToString(r.alertInfoId, "alertInfoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAlertInfosRequest struct {
	ctx context.Context
	ApiService *AlertInfosAPIService
	createAfter *string
	createBefore *string
	clusterId *string
}

// create_after start time of alert info
func (r ApiDeleteAlertInfosRequest) CreateAfter(createAfter string) ApiDeleteAlertInfosRequest {
	r.createAfter = &createAfter
	return r
}

// create_before end time of alert info
func (r ApiDeleteAlertInfosRequest) CreateBefore(createBefore string) ApiDeleteAlertInfosRequest {
	r.createBefore = &createBefore
	return r
}

// cluster id
func (r ApiDeleteAlertInfosRequest) ClusterId(clusterId string) ApiDeleteAlertInfosRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiDeleteAlertInfosRequest) Execute() (*AlertInfoBatchDeleteResp, *http.Response, error) {
	return r.ApiService.DeleteAlertInfosExecute(r)
}

/*
DeleteAlertInfos Method for DeleteAlertInfos

delete alert infos

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteAlertInfosRequest
*/
func (a *AlertInfosAPIService) DeleteAlertInfos(ctx context.Context) ApiDeleteAlertInfosRequest {
	return ApiDeleteAlertInfosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertInfoBatchDeleteResp
func (a *AlertInfosAPIService) DeleteAlertInfosExecute(r ApiDeleteAlertInfosRequest) (*AlertInfoBatchDeleteResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertInfoBatchDeleteResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertInfosAPIService.DeleteAlertInfos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alert-infos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create_after", r.createAfter, "form", "")
	}
	if r.createBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create_before", r.createBefore, "form", "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlertInfoRequest struct {
	ctx context.Context
	ApiService *AlertInfosAPIService
	alertInfoId int64
}

func (r ApiGetAlertInfoRequest) Execute() (*AlertInfoResp, *http.Response, error) {
	return r.ApiService.GetAlertInfoExecute(r)
}

/*
GetAlertInfo Method for GetAlertInfo

get an alert info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertInfoId alert info id
 @return ApiGetAlertInfoRequest
*/
func (a *AlertInfosAPIService) GetAlertInfo(ctx context.Context, alertInfoId int64) ApiGetAlertInfoRequest {
	return ApiGetAlertInfoRequest{
		ApiService: a,
		ctx: ctx,
		alertInfoId: alertInfoId,
	}
}

// Execute executes the request
//  @return AlertInfoResp
func (a *AlertInfosAPIService) GetAlertInfoExecute(r ApiGetAlertInfoRequest) (*AlertInfoResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertInfoResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertInfosAPIService.GetAlertInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alert-infos/{alert_info_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"alert_info_id"+"}", url.PathEscape(parameterValueToString(r.alertInfoId, "alertInfoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlertInfosReportRequest struct {
	ctx context.Context
	ApiService *AlertInfosAPIService
	level *string
	resourceType *string
	resourceId *int64
	createAfter *string
	acked *bool
	resolved *bool
	group *string
	excludeCluster *bool
	isGlobal *bool
}

// level of alert info
func (r ApiGetAlertInfosReportRequest) Level(level string) ApiGetAlertInfosReportRequest {
	r.level = &level
	return r
}

// resource type of alert info
func (r ApiGetAlertInfosReportRequest) ResourceType(resourceType string) ApiGetAlertInfosReportRequest {
	r.resourceType = &resourceType
	return r
}

// resource id of alert info
func (r ApiGetAlertInfosReportRequest) ResourceId(resourceId int64) ApiGetAlertInfosReportRequest {
	r.resourceId = &resourceId
	return r
}

// create_after timestamp of alert info
func (r ApiGetAlertInfosReportRequest) CreateAfter(createAfter string) ApiGetAlertInfosReportRequest {
	r.createAfter = &createAfter
	return r
}

// acked of alert info
func (r ApiGetAlertInfosReportRequest) Acked(acked bool) ApiGetAlertInfosReportRequest {
	r.acked = &acked
	return r
}

// resolved or not of alert info
func (r ApiGetAlertInfosReportRequest) Resolved(resolved bool) ApiGetAlertInfosReportRequest {
	r.resolved = &resolved
	return r
}

// group of alert info
func (r ApiGetAlertInfosReportRequest) Group(group string) ApiGetAlertInfosReportRequest {
	r.group = &group
	return r
}

// filter to exclude cluster of alert info, deprecated, use &#x60;is_global&#x60; instead.
func (r ApiGetAlertInfosReportRequest) ExcludeCluster(excludeCluster bool) ApiGetAlertInfosReportRequest {
	r.excludeCluster = &excludeCluster
	return r
}

// filter global alert info groups(exclude alert info in any cluster)
func (r ApiGetAlertInfosReportRequest) IsGlobal(isGlobal bool) ApiGetAlertInfosReportRequest {
	r.isGlobal = &isGlobal
	return r
}

func (r ApiGetAlertInfosReportRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAlertInfosReportExecute(r)
}

/*
GetAlertInfosReport Method for GetAlertInfosReport

Get report of alert infos

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAlertInfosReportRequest
*/
func (a *AlertInfosAPIService) GetAlertInfosReport(ctx context.Context) ApiGetAlertInfosReportRequest {
	return ApiGetAlertInfosReportRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *AlertInfosAPIService) GetAlertInfosReportExecute(r ApiGetAlertInfosReportRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertInfosAPIService.GetAlertInfosReport")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alert-infos/report"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource_type", r.resourceType, "form", "")
	}
	if r.resourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource_id", r.resourceId, "form", "")
	}
	if r.createAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create_after", r.createAfter, "form", "")
	}
	if r.acked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acked", r.acked, "form", "")
	}
	if r.resolved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolved", r.resolved, "form", "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "form", "")
	}
	if r.excludeCluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_cluster", r.excludeCluster, "form", "")
	}
	if r.isGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_global", r.isGlobal, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListAlertInfosRequest struct {
	ctx context.Context
	ApiService *AlertInfosAPIService
	qMust *string
	q *string
	relatedResource *string
	sort *string
	limit *int64
	offset *int64
	level *string
	resourceType *string
	resourceId *int64
	createAfter *string
	acked *bool
	resolved *bool
	group *string
	excludeCluster *bool
	isGlobal *bool
}

// must query param of search
func (r ApiListAlertInfosRequest) QMust(qMust string) ApiListAlertInfosRequest {
	r.qMust = &qMust
	return r
}

// should query param of search
func (r ApiListAlertInfosRequest) Q(q string) ApiListAlertInfosRequest {
	r.q = &q
	return r
}

// should query param of search
func (r ApiListAlertInfosRequest) RelatedResource(relatedResource string) ApiListAlertInfosRequest {
	r.relatedResource = &relatedResource
	return r
}

// sort param of search
func (r ApiListAlertInfosRequest) Sort(sort string) ApiListAlertInfosRequest {
	r.sort = &sort
	return r
}

// paging param
func (r ApiListAlertInfosRequest) Limit(limit int64) ApiListAlertInfosRequest {
	r.limit = &limit
	return r
}

// paging param
func (r ApiListAlertInfosRequest) Offset(offset int64) ApiListAlertInfosRequest {
	r.offset = &offset
	return r
}

// level of alert info
func (r ApiListAlertInfosRequest) Level(level string) ApiListAlertInfosRequest {
	r.level = &level
	return r
}

// resource type of alert info
func (r ApiListAlertInfosRequest) ResourceType(resourceType string) ApiListAlertInfosRequest {
	r.resourceType = &resourceType
	return r
}

// resource id of alert info
func (r ApiListAlertInfosRequest) ResourceId(resourceId int64) ApiListAlertInfosRequest {
	r.resourceId = &resourceId
	return r
}

// create_after timestamp of alert info
func (r ApiListAlertInfosRequest) CreateAfter(createAfter string) ApiListAlertInfosRequest {
	r.createAfter = &createAfter
	return r
}

// acked of alert info
func (r ApiListAlertInfosRequest) Acked(acked bool) ApiListAlertInfosRequest {
	r.acked = &acked
	return r
}

// resolved or not of alert info
func (r ApiListAlertInfosRequest) Resolved(resolved bool) ApiListAlertInfosRequest {
	r.resolved = &resolved
	return r
}

// group of alert info
func (r ApiListAlertInfosRequest) Group(group string) ApiListAlertInfosRequest {
	r.group = &group
	return r
}

// filter to exclude cluster of alert info, deprecated, use &#x60;is_global&#x60; instead
func (r ApiListAlertInfosRequest) ExcludeCluster(excludeCluster bool) ApiListAlertInfosRequest {
	r.excludeCluster = &excludeCluster
	return r
}

// filter global alert info(exclude alert info in any cluster)
func (r ApiListAlertInfosRequest) IsGlobal(isGlobal bool) ApiListAlertInfosRequest {
	r.isGlobal = &isGlobal
	return r
}

func (r ApiListAlertInfosRequest) Execute() (*AlertInfosResp, *http.Response, error) {
	return r.ApiService.ListAlertInfosExecute(r)
}

/*
ListAlertInfos Method for ListAlertInfos

List all alert infos

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAlertInfosRequest
*/
func (a *AlertInfosAPIService) ListAlertInfos(ctx context.Context) ApiListAlertInfosRequest {
	return ApiListAlertInfosRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AlertInfosResp
func (a *AlertInfosAPIService) ListAlertInfosExecute(r ApiListAlertInfosRequest) (*AlertInfosResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AlertInfosResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertInfosAPIService.ListAlertInfos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alert-infos/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.qMust != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q_must", r.qMust, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.relatedResource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "related_resource", r.relatedResource, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.resourceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource_type", r.resourceType, "form", "")
	}
	if r.resourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resource_id", r.resourceId, "form", "")
	}
	if r.createAfter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "create_after", r.createAfter, "form", "")
	}
	if r.acked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "acked", r.acked, "form", "")
	}
	if r.resolved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "resolved", r.resolved, "form", "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "form", "")
	}
	if r.excludeCluster != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_cluster", r.excludeCluster, "form", "")
	}
	if r.isGlobal != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_global", r.isGlobal, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResolveAlertInfoRequest struct {
	ctx context.Context
	ApiService *AlertInfosAPIService
	alertInfoId int64
}

func (r ApiResolveAlertInfoRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResolveAlertInfoExecute(r)
}

/*
ResolveAlertInfo Method for ResolveAlertInfo

set the resolved status of alert info

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param alertInfoId the id of alert info
 @return ApiResolveAlertInfoRequest
*/
func (a *AlertInfosAPIService) ResolveAlertInfo(ctx context.Context, alertInfoId int64) ApiResolveAlertInfoRequest {
	return ApiResolveAlertInfoRequest{
		ApiService: a,
		ctx: ctx,
		alertInfoId: alertInfoId,
	}
}

// Execute executes the request
func (a *AlertInfosAPIService) ResolveAlertInfoExecute(r ApiResolveAlertInfoRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertInfosAPIService.ResolveAlertInfo")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alert-infos/{alert_info_id}:resolve"
	localVarPath = strings.Replace(localVarPath, "{"+"alert_info_id"+"}", url.PathEscape(parameterValueToString(r.alertInfoId, "alertInfoId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
