/*
XMS API

XMS is the controller of distributed storage system

API version: XSCALEROS_6.4.000.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DpVolumeGroupSnapshotReplicationPairsAPIService DpVolumeGroupSnapshotReplicationPairsAPI service
type DpVolumeGroupSnapshotReplicationPairsAPIService service

type ApiAsyncFailoverDpVolumeGroupSnapshotReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpVolumeGroupSnapshotReplicationPairsAPIService
	pairId int64
}

func (r ApiAsyncFailoverDpVolumeGroupSnapshotReplicationPairRequest) Execute() (*DpVolumeGroupSnapshotReplicationPairsResp, *http.Response, error) {
	return r.ApiService.AsyncFailoverDpVolumeGroupSnapshotReplicationPairExecute(r)
}

/*
AsyncFailoverDpVolumeGroupSnapshotReplicationPair Method for AsyncFailoverDpVolumeGroupSnapshotReplicationPair

switch the roles of the pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiAsyncFailoverDpVolumeGroupSnapshotReplicationPairRequest
*/
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) AsyncFailoverDpVolumeGroupSnapshotReplicationPair(ctx context.Context, pairId int64) ApiAsyncFailoverDpVolumeGroupSnapshotReplicationPairRequest {
	return ApiAsyncFailoverDpVolumeGroupSnapshotReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpVolumeGroupSnapshotReplicationPairsResp
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) AsyncFailoverDpVolumeGroupSnapshotReplicationPairExecute(r ApiAsyncFailoverDpVolumeGroupSnapshotReplicationPairRequest) (*DpVolumeGroupSnapshotReplicationPairsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpVolumeGroupSnapshotReplicationPairsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpVolumeGroupSnapshotReplicationPairsAPIService.AsyncFailoverDpVolumeGroupSnapshotReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-volume-group-snapshot-replication-pairs/{pair_id}:async-failover"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDpVolumeGroupSnapshotReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpVolumeGroupSnapshotReplicationPairsAPIService
	body *DpVolumeGroupSnapshotReplicationPairCreateReq
}

// pair info
func (r ApiCreateDpVolumeGroupSnapshotReplicationPairRequest) Body(body DpVolumeGroupSnapshotReplicationPairCreateReq) ApiCreateDpVolumeGroupSnapshotReplicationPairRequest {
	r.body = &body
	return r
}

func (r ApiCreateDpVolumeGroupSnapshotReplicationPairRequest) Execute() (*DpVolumeGroupSnapshotReplicationPairResp, *http.Response, error) {
	return r.ApiService.CreateDpVolumeGroupSnapshotReplicationPairExecute(r)
}

/*
CreateDpVolumeGroupSnapshotReplicationPair Method for CreateDpVolumeGroupSnapshotReplicationPair

Create dp volume group snapshot replication pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDpVolumeGroupSnapshotReplicationPairRequest
*/
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) CreateDpVolumeGroupSnapshotReplicationPair(ctx context.Context) ApiCreateDpVolumeGroupSnapshotReplicationPairRequest {
	return ApiCreateDpVolumeGroupSnapshotReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DpVolumeGroupSnapshotReplicationPairResp
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) CreateDpVolumeGroupSnapshotReplicationPairExecute(r ApiCreateDpVolumeGroupSnapshotReplicationPairRequest) (*DpVolumeGroupSnapshotReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpVolumeGroupSnapshotReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpVolumeGroupSnapshotReplicationPairsAPIService.CreateDpVolumeGroupSnapshotReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-volume-group-snapshot-replication-pairs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDpVolumeGroupSnapshotReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpVolumeGroupSnapshotReplicationPairsAPIService
	pairId int64
	force *bool
}

// force delete volume group pair or not
func (r ApiDeleteDpVolumeGroupSnapshotReplicationPairRequest) Force(force bool) ApiDeleteDpVolumeGroupSnapshotReplicationPairRequest {
	r.force = &force
	return r
}

func (r ApiDeleteDpVolumeGroupSnapshotReplicationPairRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDpVolumeGroupSnapshotReplicationPairExecute(r)
}

/*
DeleteDpVolumeGroupSnapshotReplicationPair Method for DeleteDpVolumeGroupSnapshotReplicationPair

Delete dp volume group snapshot replication pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiDeleteDpVolumeGroupSnapshotReplicationPairRequest
*/
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) DeleteDpVolumeGroupSnapshotReplicationPair(ctx context.Context, pairId int64) ApiDeleteDpVolumeGroupSnapshotReplicationPairRequest {
	return ApiDeleteDpVolumeGroupSnapshotReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) DeleteDpVolumeGroupSnapshotReplicationPairExecute(r ApiDeleteDpVolumeGroupSnapshotReplicationPairRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpVolumeGroupSnapshotReplicationPairsAPIService.DeleteDpVolumeGroupSnapshotReplicationPair")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-volume-group-snapshot-replication-pairs/{pair_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetDpVolumeGroupSnapshotReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpVolumeGroupSnapshotReplicationPairsAPIService
	pairId int64
}

func (r ApiGetDpVolumeGroupSnapshotReplicationPairRequest) Execute() (*DpVolumeGroupSnapshotReplicationPairResp, *http.Response, error) {
	return r.ApiService.GetDpVolumeGroupSnapshotReplicationPairExecute(r)
}

/*
GetDpVolumeGroupSnapshotReplicationPair Method for GetDpVolumeGroupSnapshotReplicationPair

Get dp volume group snapshot replication pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiGetDpVolumeGroupSnapshotReplicationPairRequest
*/
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) GetDpVolumeGroupSnapshotReplicationPair(ctx context.Context, pairId int64) ApiGetDpVolumeGroupSnapshotReplicationPairRequest {
	return ApiGetDpVolumeGroupSnapshotReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpVolumeGroupSnapshotReplicationPairResp
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) GetDpVolumeGroupSnapshotReplicationPairExecute(r ApiGetDpVolumeGroupSnapshotReplicationPairRequest) (*DpVolumeGroupSnapshotReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpVolumeGroupSnapshotReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpVolumeGroupSnapshotReplicationPairsAPIService.GetDpVolumeGroupSnapshotReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-volume-group-snapshot-replication-pairs/{pair_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDpVolumeGroupSnapshotReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpVolumeGroupSnapshotReplicationPairsAPIService
	volumeGroupId *int64
	dpVolumeGroupSnapshotReplicationPolicyId *int64
}

// related volume group id
func (r ApiListDpVolumeGroupSnapshotReplicationPairRequest) VolumeGroupId(volumeGroupId int64) ApiListDpVolumeGroupSnapshotReplicationPairRequest {
	r.volumeGroupId = &volumeGroupId
	return r
}

// related policy id
func (r ApiListDpVolumeGroupSnapshotReplicationPairRequest) DpVolumeGroupSnapshotReplicationPolicyId(dpVolumeGroupSnapshotReplicationPolicyId int64) ApiListDpVolumeGroupSnapshotReplicationPairRequest {
	r.dpVolumeGroupSnapshotReplicationPolicyId = &dpVolumeGroupSnapshotReplicationPolicyId
	return r
}

func (r ApiListDpVolumeGroupSnapshotReplicationPairRequest) Execute() (*DpVolumeGroupSnapshotReplicationPairsResp, *http.Response, error) {
	return r.ApiService.ListDpVolumeGroupSnapshotReplicationPairExecute(r)
}

/*
ListDpVolumeGroupSnapshotReplicationPair Method for ListDpVolumeGroupSnapshotReplicationPair

List dp volume group snapshot replication pairs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDpVolumeGroupSnapshotReplicationPairRequest
*/
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) ListDpVolumeGroupSnapshotReplicationPair(ctx context.Context) ApiListDpVolumeGroupSnapshotReplicationPairRequest {
	return ApiListDpVolumeGroupSnapshotReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DpVolumeGroupSnapshotReplicationPairsResp
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) ListDpVolumeGroupSnapshotReplicationPairExecute(r ApiListDpVolumeGroupSnapshotReplicationPairRequest) (*DpVolumeGroupSnapshotReplicationPairsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpVolumeGroupSnapshotReplicationPairsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpVolumeGroupSnapshotReplicationPairsAPIService.ListDpVolumeGroupSnapshotReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-volume-group-snapshot-replication-pairs/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.volumeGroupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "volume_group_id", r.volumeGroupId, "form", "")
	}
	if r.dpVolumeGroupSnapshotReplicationPolicyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dp_volume_group_snapshot_replication_policy_id", r.dpVolumeGroupSnapshotReplicationPolicyId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPauseDpVolumeGroupSnapshotReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpVolumeGroupSnapshotReplicationPairsAPIService
	pairId int64
}

func (r ApiPauseDpVolumeGroupSnapshotReplicationPairRequest) Execute() (*DpVolumeGroupSnapshotReplicationPairsResp, *http.Response, error) {
	return r.ApiService.PauseDpVolumeGroupSnapshotReplicationPairExecute(r)
}

/*
PauseDpVolumeGroupSnapshotReplicationPair Method for PauseDpVolumeGroupSnapshotReplicationPair

pause periodic sync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiPauseDpVolumeGroupSnapshotReplicationPairRequest
*/
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) PauseDpVolumeGroupSnapshotReplicationPair(ctx context.Context, pairId int64) ApiPauseDpVolumeGroupSnapshotReplicationPairRequest {
	return ApiPauseDpVolumeGroupSnapshotReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpVolumeGroupSnapshotReplicationPairsResp
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) PauseDpVolumeGroupSnapshotReplicationPairExecute(r ApiPauseDpVolumeGroupSnapshotReplicationPairRequest) (*DpVolumeGroupSnapshotReplicationPairsResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpVolumeGroupSnapshotReplicationPairsResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpVolumeGroupSnapshotReplicationPairsAPIService.PauseDpVolumeGroupSnapshotReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-volume-group-snapshot-replication-pairs/{pair_id}:pause"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResumeDpVolumeGroupSnapshotReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpVolumeGroupSnapshotReplicationPairsAPIService
	pairId int64
}

func (r ApiResumeDpVolumeGroupSnapshotReplicationPairRequest) Execute() (*DpVolumeGroupSnapshotReplicationPairResp, *http.Response, error) {
	return r.ApiService.ResumeDpVolumeGroupSnapshotReplicationPairExecute(r)
}

/*
ResumeDpVolumeGroupSnapshotReplicationPair Method for ResumeDpVolumeGroupSnapshotReplicationPair

resume periodic sync

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiResumeDpVolumeGroupSnapshotReplicationPairRequest
*/
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) ResumeDpVolumeGroupSnapshotReplicationPair(ctx context.Context, pairId int64) ApiResumeDpVolumeGroupSnapshotReplicationPairRequest {
	return ApiResumeDpVolumeGroupSnapshotReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpVolumeGroupSnapshotReplicationPairResp
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) ResumeDpVolumeGroupSnapshotReplicationPairExecute(r ApiResumeDpVolumeGroupSnapshotReplicationPairRequest) (*DpVolumeGroupSnapshotReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpVolumeGroupSnapshotReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpVolumeGroupSnapshotReplicationPairsAPIService.ResumeDpVolumeGroupSnapshotReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-volume-group-snapshot-replication-pairs/{pair_id}:resume"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDpVolumeGroupSnapshotReplicationPairRequest struct {
	ctx context.Context
	ApiService *DpVolumeGroupSnapshotReplicationPairsAPIService
	pairId int64
	body *DpVolumeGroupSnapshotReplicationPairUpdateReq
}

// pair info
func (r ApiUpdateDpVolumeGroupSnapshotReplicationPairRequest) Body(body DpVolumeGroupSnapshotReplicationPairUpdateReq) ApiUpdateDpVolumeGroupSnapshotReplicationPairRequest {
	r.body = &body
	return r
}

func (r ApiUpdateDpVolumeGroupSnapshotReplicationPairRequest) Execute() (*DpVolumeGroupSnapshotReplicationPairResp, *http.Response, error) {
	return r.ApiService.UpdateDpVolumeGroupSnapshotReplicationPairExecute(r)
}

/*
UpdateDpVolumeGroupSnapshotReplicationPair Method for UpdateDpVolumeGroupSnapshotReplicationPair

Update dp volume group snapshot replication pair

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pairId resource id
 @return ApiUpdateDpVolumeGroupSnapshotReplicationPairRequest
*/
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) UpdateDpVolumeGroupSnapshotReplicationPair(ctx context.Context, pairId int64) ApiUpdateDpVolumeGroupSnapshotReplicationPairRequest {
	return ApiUpdateDpVolumeGroupSnapshotReplicationPairRequest{
		ApiService: a,
		ctx: ctx,
		pairId: pairId,
	}
}

// Execute executes the request
//  @return DpVolumeGroupSnapshotReplicationPairResp
func (a *DpVolumeGroupSnapshotReplicationPairsAPIService) UpdateDpVolumeGroupSnapshotReplicationPairExecute(r ApiUpdateDpVolumeGroupSnapshotReplicationPairRequest) (*DpVolumeGroupSnapshotReplicationPairResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DpVolumeGroupSnapshotReplicationPairResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DpVolumeGroupSnapshotReplicationPairsAPIService.UpdateDpVolumeGroupSnapshotReplicationPair")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dp-volume-group-snapshot-replication-pairs/{pair_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"pair_id"+"}", url.PathEscape(parameterValueToString(r.pairId, "pairId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
