/*
XMS API

XMS is the controller of distributed storage system

API version: XSCALEROS_6.4.000.2
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DfsTrashesAPIService DfsTrashesAPI service
type DfsTrashesAPIService service

type ApiCloseDfsTrashRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	dfsTrashId int64
}

func (r ApiCloseDfsTrashRequest) Execute() (*DfsTrashResp, *http.Response, error) {
	return r.ApiService.CloseDfsTrashExecute(r)
}

/*
CloseDfsTrash Method for CloseDfsTrash

Close dfs trash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dfsTrashId trash id
 @return ApiCloseDfsTrashRequest
*/
func (a *DfsTrashesAPIService) CloseDfsTrash(ctx context.Context, dfsTrashId int64) ApiCloseDfsTrashRequest {
	return ApiCloseDfsTrashRequest{
		ApiService: a,
		ctx: ctx,
		dfsTrashId: dfsTrashId,
	}
}

// Execute executes the request
//  @return DfsTrashResp
func (a *DfsTrashesAPIService) CloseDfsTrashExecute(r ApiCloseDfsTrashRequest) (*DfsTrashResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.CloseDfsTrash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/{dfs_trash_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"dfs_trash_id"+"}", url.PathEscape(parameterValueToString(r.dfsTrashId, "dfsTrashId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEmptyDfsTrashRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	dfsTrashId int64
	force *bool
}

// force empty
func (r ApiEmptyDfsTrashRequest) Force(force bool) ApiEmptyDfsTrashRequest {
	r.force = &force
	return r
}

func (r ApiEmptyDfsTrashRequest) Execute() (*DfsTrashResp, *http.Response, error) {
	return r.ApiService.EmptyDfsTrashExecute(r)
}

/*
EmptyDfsTrash Method for EmptyDfsTrash

Empty dfs trash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dfsTrashId trash id
 @return ApiEmptyDfsTrashRequest
*/
func (a *DfsTrashesAPIService) EmptyDfsTrash(ctx context.Context, dfsTrashId int64) ApiEmptyDfsTrashRequest {
	return ApiEmptyDfsTrashRequest{
		ApiService: a,
		ctx: ctx,
		dfsTrashId: dfsTrashId,
	}
}

// Execute executes the request
//  @return DfsTrashResp
func (a *DfsTrashesAPIService) EmptyDfsTrashExecute(r ApiEmptyDfsTrashRequest) (*DfsTrashResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.EmptyDfsTrash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/{dfs_trash_id}:empty"
	localVarPath = strings.Replace(localVarPath, "{"+"dfs_trash_id"+"}", url.PathEscape(parameterValueToString(r.dfsTrashId, "dfsTrashId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDfsTrashRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	dfsTrashId int64
}

func (r ApiGetDfsTrashRequest) Execute() (*DfsTrashResp, *http.Response, error) {
	return r.ApiService.GetDfsTrashExecute(r)
}

/*
GetDfsTrash Method for GetDfsTrash

Get dfs trash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dfsTrashId trash id
 @return ApiGetDfsTrashRequest
*/
func (a *DfsTrashesAPIService) GetDfsTrash(ctx context.Context, dfsTrashId int64) ApiGetDfsTrashRequest {
	return ApiGetDfsTrashRequest{
		ApiService: a,
		ctx: ctx,
		dfsTrashId: dfsTrashId,
	}
}

// Execute executes the request
//  @return DfsTrashResp
func (a *DfsTrashesAPIService) GetDfsTrashExecute(r ApiGetDfsTrashRequest) (*DfsTrashResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.GetDfsTrash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/{dfs_trash_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"dfs_trash_id"+"}", url.PathEscape(parameterValueToString(r.dfsTrashId, "dfsTrashId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDfsTrashFileJobsRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	limit *int64
	offset *int64
	clusterId *string
	dfsTrashId *string
	path *string
	action *string
}

// paging param
func (r ApiListDfsTrashFileJobsRequest) Limit(limit int64) ApiListDfsTrashFileJobsRequest {
	r.limit = &limit
	return r
}

// paging param
func (r ApiListDfsTrashFileJobsRequest) Offset(offset int64) ApiListDfsTrashFileJobsRequest {
	r.offset = &offset
	return r
}

// cluster id
func (r ApiListDfsTrashFileJobsRequest) ClusterId(clusterId string) ApiListDfsTrashFileJobsRequest {
	r.clusterId = &clusterId
	return r
}

// trash id
func (r ApiListDfsTrashFileJobsRequest) DfsTrashId(dfsTrashId string) ApiListDfsTrashFileJobsRequest {
	r.dfsTrashId = &dfsTrashId
	return r
}

// path
func (r ApiListDfsTrashFileJobsRequest) Path(path string) ApiListDfsTrashFileJobsRequest {
	r.path = &path
	return r
}

// action
func (r ApiListDfsTrashFileJobsRequest) Action(action string) ApiListDfsTrashFileJobsRequest {
	r.action = &action
	return r
}

func (r ApiListDfsTrashFileJobsRequest) Execute() (*DfsTrashFileJobResp, *http.Response, error) {
	return r.ApiService.ListDfsTrashFileJobsExecute(r)
}

/*
ListDfsTrashFileJobs Method for ListDfsTrashFileJobs

List dfs trash file job

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDfsTrashFileJobsRequest
*/
func (a *DfsTrashesAPIService) ListDfsTrashFileJobs(ctx context.Context) ApiListDfsTrashFileJobsRequest {
	return ApiListDfsTrashFileJobsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DfsTrashFileJobResp
func (a *DfsTrashesAPIService) ListDfsTrashFileJobsExecute(r ApiListDfsTrashFileJobsRequest) (*DfsTrashFileJobResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashFileJobResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.ListDfsTrashFileJobs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/:list_trash_file_jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	if r.dfsTrashId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dfs_trash_id", r.dfsTrashId, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.action != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDfsTrashFilesRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	dfsTrashId int64
	limit *int64
	path *string
	start *string
	prefix *string
}

// paging param
func (r ApiListDfsTrashFilesRequest) Limit(limit int64) ApiListDfsTrashFilesRequest {
	r.limit = &limit
	return r
}

// parent path
func (r ApiListDfsTrashFilesRequest) Path(path string) ApiListDfsTrashFilesRequest {
	r.path = &path
	return r
}

// start file for list
func (r ApiListDfsTrashFilesRequest) Start(start string) ApiListDfsTrashFilesRequest {
	r.start = &start
	return r
}

// prefix to filter file or directory
func (r ApiListDfsTrashFilesRequest) Prefix(prefix string) ApiListDfsTrashFilesRequest {
	r.prefix = &prefix
	return r
}

func (r ApiListDfsTrashFilesRequest) Execute() (*DfsTrashFilesResp, *http.Response, error) {
	return r.ApiService.ListDfsTrashFilesExecute(r)
}

/*
ListDfsTrashFiles Method for ListDfsTrashFiles

List dfs trash files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dfsTrashId trash id
 @return ApiListDfsTrashFilesRequest
*/
func (a *DfsTrashesAPIService) ListDfsTrashFiles(ctx context.Context, dfsTrashId int64) ApiListDfsTrashFilesRequest {
	return ApiListDfsTrashFilesRequest{
		ApiService: a,
		ctx: ctx,
		dfsTrashId: dfsTrashId,
	}
}

// Execute executes the request
//  @return DfsTrashFilesResp
func (a *DfsTrashesAPIService) ListDfsTrashFilesExecute(r ApiListDfsTrashFilesRequest) (*DfsTrashFilesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashFilesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.ListDfsTrashFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/{dfs_trash_id}:list_trash_files"
	localVarPath = strings.Replace(localVarPath, "{"+"dfs_trash_id"+"}", url.PathEscape(parameterValueToString(r.dfsTrashId, "dfsTrashId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListDfsTrashesRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	limit *int64
	offset *int64
	q *string
	sort *string
	clusterId *string
	status *string
}

// paging param
func (r ApiListDfsTrashesRequest) Limit(limit int64) ApiListDfsTrashesRequest {
	r.limit = &limit
	return r
}

// paging param
func (r ApiListDfsTrashesRequest) Offset(offset int64) ApiListDfsTrashesRequest {
	r.offset = &offset
	return r
}

// query param of search
func (r ApiListDfsTrashesRequest) Q(q string) ApiListDfsTrashesRequest {
	r.q = &q
	return r
}

// sort param of search
func (r ApiListDfsTrashesRequest) Sort(sort string) ApiListDfsTrashesRequest {
	r.sort = &sort
	return r
}

// cluster id
func (r ApiListDfsTrashesRequest) ClusterId(clusterId string) ApiListDfsTrashesRequest {
	r.clusterId = &clusterId
	return r
}

// status
func (r ApiListDfsTrashesRequest) Status(status string) ApiListDfsTrashesRequest {
	r.status = &status
	return r
}

func (r ApiListDfsTrashesRequest) Execute() (*DfsTrashesResp, *http.Response, error) {
	return r.ApiService.ListDfsTrashesExecute(r)
}

/*
ListDfsTrashes Method for ListDfsTrashes

List dfs trashes

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListDfsTrashesRequest
*/
func (a *DfsTrashesAPIService) ListDfsTrashes(ctx context.Context) ApiListDfsTrashesRequest {
	return ApiListDfsTrashesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DfsTrashesResp
func (a *DfsTrashesAPIService) ListDfsTrashesExecute(r ApiListDfsTrashesRequest) (*DfsTrashesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.ListDfsTrashes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "form", "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	}
	if r.clusterId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cluster_id", r.clusterId, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOpenDfsTrashRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	body *DfsTrashOpenReq
	allowPathCreate *bool
}

// trash info
func (r ApiOpenDfsTrashRequest) Body(body DfsTrashOpenReq) ApiOpenDfsTrashRequest {
	r.body = &body
	return r
}

// allow create path when not existed
func (r ApiOpenDfsTrashRequest) AllowPathCreate(allowPathCreate bool) ApiOpenDfsTrashRequest {
	r.allowPathCreate = &allowPathCreate
	return r
}

func (r ApiOpenDfsTrashRequest) Execute() (*DfsTrashResp, *http.Response, error) {
	return r.ApiService.OpenDfsTrashExecute(r)
}

/*
OpenDfsTrash Method for OpenDfsTrash

Create dfs trash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOpenDfsTrashRequest
*/
func (a *DfsTrashesAPIService) OpenDfsTrash(ctx context.Context) ApiOpenDfsTrashRequest {
	return ApiOpenDfsTrashRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DfsTrashResp
func (a *DfsTrashesAPIService) OpenDfsTrashExecute(r ApiOpenDfsTrashRequest) (*DfsTrashResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.OpenDfsTrash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.allowPathCreate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allow_path_create", r.allowPathCreate, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveDfsTrashFileRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	dfsTrashId int64
	body *DfsTrashRemoveFileReq
}

// trash info
func (r ApiRemoveDfsTrashFileRequest) Body(body DfsTrashRemoveFileReq) ApiRemoveDfsTrashFileRequest {
	r.body = &body
	return r
}

func (r ApiRemoveDfsTrashFileRequest) Execute() (*DfsTrashFileJobResp, *http.Response, error) {
	return r.ApiService.RemoveDfsTrashFileExecute(r)
}

/*
RemoveDfsTrashFile Method for RemoveDfsTrashFile

Remove dfs trash file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dfsTrashId trash id
 @return ApiRemoveDfsTrashFileRequest
*/
func (a *DfsTrashesAPIService) RemoveDfsTrashFile(ctx context.Context, dfsTrashId int64) ApiRemoveDfsTrashFileRequest {
	return ApiRemoveDfsTrashFileRequest{
		ApiService: a,
		ctx: ctx,
		dfsTrashId: dfsTrashId,
	}
}

// Execute executes the request
//  @return DfsTrashFileJobResp
func (a *DfsTrashesAPIService) RemoveDfsTrashFileExecute(r ApiRemoveDfsTrashFileRequest) (*DfsTrashFileJobResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashFileJobResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.RemoveDfsTrashFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/{dfs_trash_id}:remove-file"
	localVarPath = strings.Replace(localVarPath, "{"+"dfs_trash_id"+"}", url.PathEscape(parameterValueToString(r.dfsTrashId, "dfsTrashId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreDfsTrashFileRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	dfsTrashId int64
	body *DfsTrashRestoreFileReq
	force *bool
}

// trash info
func (r ApiRestoreDfsTrashFileRequest) Body(body DfsTrashRestoreFileReq) ApiRestoreDfsTrashFileRequest {
	r.body = &body
	return r
}

// force restore
func (r ApiRestoreDfsTrashFileRequest) Force(force bool) ApiRestoreDfsTrashFileRequest {
	r.force = &force
	return r
}

func (r ApiRestoreDfsTrashFileRequest) Execute() (*DfsTrashFileJobResp, *http.Response, error) {
	return r.ApiService.RestoreDfsTrashFileExecute(r)
}

/*
RestoreDfsTrashFile Method for RestoreDfsTrashFile

Restore dfs trash file

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dfsTrashId trash id
 @return ApiRestoreDfsTrashFileRequest
*/
func (a *DfsTrashesAPIService) RestoreDfsTrashFile(ctx context.Context, dfsTrashId int64) ApiRestoreDfsTrashFileRequest {
	return ApiRestoreDfsTrashFileRequest{
		ApiService: a,
		ctx: ctx,
		dfsTrashId: dfsTrashId,
	}
}

// Execute executes the request
//  @return DfsTrashFileJobResp
func (a *DfsTrashesAPIService) RestoreDfsTrashFileExecute(r ApiRestoreDfsTrashFileRequest) (*DfsTrashFileJobResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashFileJobResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.RestoreDfsTrashFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/{dfs_trash_id}:restore-file"
	localVarPath = strings.Replace(localVarPath, "{"+"dfs_trash_id"+"}", url.PathEscape(parameterValueToString(r.dfsTrashId, "dfsTrashId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.force != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "force", r.force, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchDfsTrashFilesRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	dfsTrashId int64
	limit *int64
	path *string
	start *string
	prefix *string
}

// paging param
func (r ApiSearchDfsTrashFilesRequest) Limit(limit int64) ApiSearchDfsTrashFilesRequest {
	r.limit = &limit
	return r
}

// subdirectory of trash path
func (r ApiSearchDfsTrashFilesRequest) Path(path string) ApiSearchDfsTrashFilesRequest {
	r.path = &path
	return r
}

// start file for list
func (r ApiSearchDfsTrashFilesRequest) Start(start string) ApiSearchDfsTrashFilesRequest {
	r.start = &start
	return r
}

// prefix to filter file or directory
func (r ApiSearchDfsTrashFilesRequest) Prefix(prefix string) ApiSearchDfsTrashFilesRequest {
	r.prefix = &prefix
	return r
}

func (r ApiSearchDfsTrashFilesRequest) Execute() (*DfsTrashFilesResp, *http.Response, error) {
	return r.ApiService.SearchDfsTrashFilesExecute(r)
}

/*
SearchDfsTrashFiles Method for SearchDfsTrashFiles

Search dfs trash files

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dfsTrashId trash id
 @return ApiSearchDfsTrashFilesRequest
*/
func (a *DfsTrashesAPIService) SearchDfsTrashFiles(ctx context.Context, dfsTrashId int64) ApiSearchDfsTrashFilesRequest {
	return ApiSearchDfsTrashFilesRequest{
		ApiService: a,
		ctx: ctx,
		dfsTrashId: dfsTrashId,
	}
}

// Execute executes the request
//  @return DfsTrashFilesResp
func (a *DfsTrashesAPIService) SearchDfsTrashFilesExecute(r ApiSearchDfsTrashFilesRequest) (*DfsTrashFilesResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashFilesResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.SearchDfsTrashFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/{dfs_trash_id}:search_trash_files"
	localVarPath = strings.Replace(localVarPath, "{"+"dfs_trash_id"+"}", url.PathEscape(parameterValueToString(r.dfsTrashId, "dfsTrashId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.path != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "path", r.path, "form", "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "form", "")
	}
	if r.prefix != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "prefix", r.prefix, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDfsTrashRequest struct {
	ctx context.Context
	ApiService *DfsTrashesAPIService
	dfsTrashId int64
	body *DfsTrashUpdateReq
}

// trash info
func (r ApiUpdateDfsTrashRequest) Body(body DfsTrashUpdateReq) ApiUpdateDfsTrashRequest {
	r.body = &body
	return r
}

func (r ApiUpdateDfsTrashRequest) Execute() (*DfsTrashResp, *http.Response, error) {
	return r.ApiService.UpdateDfsTrashExecute(r)
}

/*
UpdateDfsTrash Method for UpdateDfsTrash

Update dfs trash

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dfsTrashId trash id
 @return ApiUpdateDfsTrashRequest
*/
func (a *DfsTrashesAPIService) UpdateDfsTrash(ctx context.Context, dfsTrashId int64) ApiUpdateDfsTrashRequest {
	return ApiUpdateDfsTrashRequest{
		ApiService: a,
		ctx: ctx,
		dfsTrashId: dfsTrashId,
	}
}

// Execute executes the request
//  @return DfsTrashResp
func (a *DfsTrashesAPIService) UpdateDfsTrashExecute(r ApiUpdateDfsTrashRequest) (*DfsTrashResp, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DfsTrashResp
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DfsTrashesAPIService.UpdateDfsTrash")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dfs-trashes/{dfs_trash_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"dfs_trash_id"+"}", url.PathEscape(parameterValueToString(r.dfsTrashId, "dfsTrashId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInHeader"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Xms-Auth-Token"] = key
			}
		}
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["tokenInQuery"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("token", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
